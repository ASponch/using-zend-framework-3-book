<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="description" content="A free and open-source book about Zend Framework 3">
<meta name="keywords" content="zend framework,book,free book,zend framework book,free zend framework book,zf3 book,free zf3 book,zend book,tutorial,zend framework tutorial">
<meta name="author" content="(c) 2016 by Oleg Krivtsov">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="../favicon.ico" rel="shortcut icon" type="image/ico" />
<link href="../assets/css/style.css" type="text/css" rel="stylesheet" />
<title>Website Operation -- Using Zend Framework 3</title>
</head>
<body>
<header>
    <div class="header">
        <div class="header-body">
            <div class="book-title">
                <a href="../index.html">Using Zend Framework 3</a>
            </div>
            <div class="book-subtitle">
                A free and open-source book about Zend Framework 3            </div>
            <nav>
                <div class="menu">
                                        <div class="link">
                        <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/html">Read</a>
                    </div>
                                        <div class="link">
                        <a href="https://github.com/olegkrivtsov/using-zf3-book-samples">Samples</a>
                    </div>
                                        <div class="link">
                        <a href="https://github.com/olegkrivtsov/using-zend-framework-3-book">Contribute</a>
                    </div>
                    
                </div>
            </nav>
        </div>    
    </div>
</header>    
<div id="container">
<!-- Navigation -->
<div class="navigation">
    <div class="prev-chapter">
        
        <a href="Zend_Skeleton_Application.html">
            <img alt="Previous Chapter" src="../assets/images/left.png"><span class="nav-btn-text">Previous</span>
        </a>
        </div>    
    <div class="contents">
        <a href="toc.html">
            <img alt="Contents" src="../assets/images/book.png"><span class="nav-btn-text">Contents</span>
        </a>
    </div>
    <div class="next-chapter">
                <a href="Model_View_Controller.html">
            <span class="nav-btn-text">Next</span><img alt="Next Chapter" src="../assets/images/right.png">
        </a>
            </div>    
</div>

ï»¿<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Using Zend Framework 3 Book - Chapter - Adaptive -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3933778336056438"
     data-ad-slot="4531860323"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!-- Chapter content -->
<div id="chapter_content">

<h1 id="operation">3. Website Operation</h1>
<p>In this chapter we will provide some theory on how a typical Zend Framework 3 based web application
works. You'll learn how PHP namespaces are used for avoiding name collisions, 
what class autoloading is, how to define application configuration parameters and 
the stages present in an application's life-cycle. You will also become familiar with such
important ZF3 components as <code>Zend\EventManager</code>, <code>Zend\ModuleManager</code> and <code>Zend\ServiceManager</code>.
If instead of learning the theory, you want to have some practical examples, skip this chapter
and refer directly to <a href="Model_View_Controller.html">Model-View-Controller</a>.</p>
<p>ZF3 components covered in this chapter:</p>
<div class="table-wrapper">
<table>
<thead>
<tr>
<th> <em>Component</em>                    </th>
<th> <em>Description</em>                                                 </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>Zend\Mvc</code>                                                      </td>
<td>  Support of Model-View-Controller pattern. Separation of business    logic from presentation.                                      </td>
</tr>
<tr>
<td> <code>Zend\ModuleManager</code>           </td>
<td> This component is responsible for loading and initializing modules of the web application. </td>
</tr>
<tr>
<td> <code>Zend\EventManager</code>            </td>
<td> This component implements functionality for triggering events and event handling. </td>
</tr>
<tr>
<td> <code>Zend\ServiceManager</code>          </td>
<td> Implements the registry of all services available in the web application. </td>
</tr>
</tbody>
</table>
</div>
<h2 id="header-44">3.1. PHP Namespaces</h2>
<p>When you use classes from different libraries (or even classes from different components of a single library) 
in your program, the class names may conflict.
This means you can encounter two classes having the same name, resulting in a PHP interpreter error.
If you've ever programmed websites with Zend Framework 1, you might remember those <em>extra</em> long
class names like <code>Zend_Controller_Abstract</code>. The idea with long names was
utilized to avoid name collisions between different components. Each component defined 
its own name prefix, like <code>Zend_</code> or <code>My_</code>. </p>
<p>To achieve the same goal, Zend Framework 3 uses a PHP language feature called <em>namespaces</em>. 
The namespaces allow to solve name collisions between code components, and provide you with the 
ability to make the long names shorter. </p>
<p>A namespace is a container for a group of names. You can nest namespaces into each other.
If a class or function does not define a namespace, it lives inside of the <em>global</em> namespace 
(for example, PHP classes <code>Exception</code> and <code>DateTime</code> belong to global namespace).</p>
<p>A real-world example of a namespace definition (taken from <em>Zend\Mvc</em> component) is presented 
below:</p>
<pre class="line-numbers"><code class="language-php">&lt;?php
namespace Zend\Mvc;

/**
 * Main application class for invoking applications.
 */
class Application 
{
  // ... class members were omitted for simplicity ...
}
</code></pre>
<blockquote class="notquote information" data-type="information"><p> You may notice that in example above we have the opening <code>&lt;?php</code> tag which
 tells the PHP engine that the text after the tag is a PHP code. In example above, when the file contains
 only the PHP code (without mixing PHP and HTML tags), you don't need to insert the 
 closing <code>?&gt;</code> tag after the end of the code. Moreover, this is not recommended and may cause undesired
 effects, if you occasionally add some character after the closing <code>?&gt;</code> tag.</p>
</blockquote><p>In Zend Framework 3, all classes belong to top-level <em>Zend</em> namespace.
The line 2 defines the namespace <em>Mvc</em>, which is nested into <em>Zend</em> namespace,
and all classes of this component (including the <code>Application</code> class shown in 
this example on lines 7-10) belong to this namespace. You separate nested
namespace names with the back-slash character ('\').</p>
<p>In other parts of code, you reference the <code>Application</code> class using
its fully-qualified name:</p>
<pre class=""><code class="language-php">&lt;?php
$application = new \Zend\Mvc\Application;
</code></pre>
<blockquote class="notquote information" data-type="information"><p> Please note the leading back-slash in <code>\Zend\Mvc\Application</code>
name. If you specify a class name with leading back-slash, this means the fully-qualified class name.
If is also possible to specify class name relatively to the current namespace, in that case you do not
specify the leading back-slash.</p>
</blockquote><p>It is also possible to use the <em>alias</em> (short name for the class) with the
help of PHP's <code>use</code> statement:</p>
<pre class=""><code class="language-php">&lt;?php
// Define the alias in the beginning of the file.
use Zend\Mvc\Application;

// Later in your code, use the short class name.
$application = new Application;
</code></pre>
<blockquote class="notquote tip" data-type="tip"><p> Although the alias allows to use a short class name instead of the full name,
 its usage is optional. You are not required to always use aliases, and can
 refer the class by its fully-qualified name.</p>
</blockquote><p>Every PHP file of your application typically defines the namespace
(except <em>index.php</em> entry script and config files, which typically do not).
For example, the main module of your site, the <em>Application</em> module,
defines its own namespace whose name equals to the module name:</p>
<pre class=""><code class="language-php">&lt;?php
namespace Application;

class Module 
{
    // ... class members were omitted for simplicity ...
}
</code></pre>
<h2 id="header-45">3.2. PHP Interfaces</h2>
<p>In PHP, <em>interfaces</em> allow you to define which behavior a class
should have, but without providing the implementation of such a behavior. This is also
called a <em>contract</em>: by implementing an interface, a class agrees to the contract terms.</p>
<p>In Zend Framework 3, interfaces are widely used. For example, the <code>Application</code> class implements the
<code>ApplicationInterface</code>, which defines the methods every application class must provide:</p>
<pre class=""><code class="language-php">&lt;?php 
namespace Zend\Mvc;

interface ApplicationInterface
{
    // Retrieves the service manager.
    public function getServiceManager();

    // Retrieves the HTTP request object.
    public function getRequest();

    // Retrieves the HTTP response object.
    public function getResponse();

    // Runs the application.
    public function run();
}
</code></pre>
<p>As you can see from the example above, an interface is defined using the <code>interface</code> 
keyword, almost the same way you define a standard PHP class. As a usual class,
the interface defines methods. However, the interface does not provide any implementation 
of its methods. In the <code>ApplicationInterface</code> interface definition above, you can
see that every application implementing this interface will have method <code>getServiceManager()</code> for
retrieving the service manager (about the service manager, see later in this chapter), the 
<code>getRequest()</code> and <code>getResponse()</code> methods for retrieving the HTTP request and response, respectively,
and method <code>run()</code> for running the application.</p>
<blockquote class="notquote information" data-type="information"><p> In Zend Framework 3, by convention, interface classes should be named with <code>Interface</code> suffix, 
like <code>ApplicationInterface</code>. </p>
</blockquote><p>A class implementing an interface is called a <em>concrete</em> class. The concrete <code>Application</code> class 
implements the <code>ApplicationInterface</code>, which means it provides the implementation of the methods
defined by the interface:</p>
<pre class=""><code class="language-php">&lt;?php 
namespace Zend\Mvc;

class Application implements ApplicationInterface
{
  // Implement the interface's methods here
   
  public function getServiceManager() 
  {
    // Provide some implementation...
  }

  public function getRequest() 
  {
    // Provide some implementation...
  }

  public function getResponse() 
  {
    // Provide some implementation...
  }

  public function run() 
  {
    // Provide some implementation...
  }
}
</code></pre>
<p>The concrete <code>Application</code> class uses the <code>implements</code> keyword to show that it
provides an implementation of all methods of <code>ApplicationInterface</code> interface.
The <code>Application</code> class can also have additional methods, which are not part
of the interface.</p>
<p>Graphically, the class relations are displayed using inheritance diagrams.
In figure 3.1, the diagram for <code>Application</code> class is presented. The arrow
points from the child class to the parent class.</p>
<p><span class="image-wrapper">
<a target="_blank" href="images/operation/Application.png">
<img src="images/operation/Application.png" alt="Figure 3.1. Application class diagram" /></a>
<span class="image-caption">Figure 3.1. Application class diagram</span>
</span>
</p>
<h2 id="header-46">3.3. PHP Class Autoloading</h2>
<p>A web application consists of many PHP classes, and
each class typically resides in a separate file. This introduces
the need of <em>including</em> the files. </p>
<p>For example, let's assume we have the file named <em>Application.php</em> 
which contains the definition for the <code>\Zend\Mvc\Application</code> class 
from the previous section. Before you can 
create an instance of the <code>Application</code> class somewhere in your code, 
you have to include the contents of <em>Application.php</em> file (you can do this with the
help of <code>require_once</code> statement, passing it the full path to the file):</p>
<pre class=""><code class="language-php">&lt;?php
require_once "/path/to/zend/lib/Application.php";

use Zend\Mvc\Application;

$application = new Application;
</code></pre>
<p>As your application grows in size, it may be difficult to include
each needed file. Zend Framework 3 itself consists of hundreds of files,
and it can be very difficult to load the entire library and all its 
dependencies this way. Moreover, when executing the resulting code, PHP interpreter will 
take CPU time to process each included file, even if you don't create an 
instance of its class.</p>
<p>To fix this problem, in PHP, the class autoloading feature has been introduced.
The PHP function <code>spl_autoload_register()</code> allows you to register 
an <em>autoloader</em> function. For complex websites, you even can create
several autoloader functions, which are chained in a stack. </p>
<p>During script execution, if PHP interpreter encounters a class name 
which has not been defined yet, it calls all the registered autoloader functions
in turn, until either the autoloader function includes the class or "not found" error is
raised. This allows for "lazy" loading, when PHP interpreter processes the class
definition only at the moment of class invocation, when it is really needed.</p>
<p>To give you an idea of how an autoloader function looks like, below we provide a
simplified implementation of an autoloader function:</p>
<pre class=""><code class="language-php">&lt;?php
// Autoloader function.
function autoloadFunc($className) 
{
  // Class map static array.
  static $classMap = [
    '\\Zend\\Mvc\\Application' =&gt; '/path/to/zend/dir/Zend/Mvc/Application.php',
    '\\Application\\Module' =&gt; '/path/to/app/dir/Application/Module.php',
    //...
  ];

  // Check if such a class name presents in the class map.
  if(isset(static::$classMap[$className])) {
    $fileName = static::$classMap[$className];
  
    // Check if file exists and is readable.
    if (is_readable($filename)) {
      // Include the file.
      require $filename;
    }
  }
}

// Register our autoloader function.
spl_autoload_register("autoloadFunc");
</code></pre>
<p>In the above example, we define the <code>autoloadFunc()</code> autoloader function, 
which we will further refer to as the <em>class map</em> autoloader.</p>
<p>The class map autoloader uses the class map for mapping between class name and 
absolute path to PHP file containing that class. The class map is just a usual PHP
array containing keys and values. To determine the file path by class name, the 
class map autoloader just needs to fetch the value from the class map array.
It is obvious, that the class map autoloader works very fast. However, the disadvantage 
of it is that you have to maintain the class map and update it each time you add a new 
class to your program.</p>
<h2 id="header-47">3.4. PSR-0 Standard</h2>
<p>Because each library's vendor uses its own code naming and file organization conventions,
you will have to register a different custom autoloader function per each dependent library,
which is rather annoying (and actually this is an unneeded work). To resolve this problem, 
the PSR-0 and PSR-4 standards were introduced.</p>
<blockquote class="notquote information" data-type="information"><p> PSR stands for PHP Standards Recommendation.</p>
</blockquote><p>The <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">PSR-0 standard</a>
defines the recommended code structure that an application or library must follow
to guarantee autoloader interoperability. In two words, the standard says that:</p>
<ul>
<li><p>The class namespaces should be organized in the following way: </p>
<p><code>\&lt;Vendor Name&gt;\(&lt;Namespace&gt;)*\&lt;Class Name&gt;</code></p>
</li>
<li><p>Namespaces can have as many nesting levels as desired, 
but the <em>Vendor Name</em> should be the top-level namespace. </p>
</li>
<li><p>Namespaces should map to directory structure. Each namespace separator ('\')
is converted to a OS-specific <code>DIRECTORY_SEPARATOR</code> constant when loading from the file system.</p>
</li>
<li><p>The class name is suffixed with <em>.php</em> extension when loading the file from the file system.</p>
</li>
</ul>
<p>For example, for the <code>Zend\Mvc\Application</code> class, 
you will have the following directory structure:</p>
<pre class=""><code class="language-text">/path/to/zend/lib
  /Zend
    /Mvc
       Application.php
</code></pre>
<p>For the code conforming to the PSR-0 standard, we can write and register 
an autoloader, which we will refer to as the "standard" autoloader:</p>
<pre class=""><code class="language-php">&lt;?php

// "Standard" autoloader function.
function standardAutoloadFunc($className) 
{
  // Replace special characters in class name.
  $className = str_replace('\\', '/', $className);
  // Format the file path.
  $fileName = "/path/to/zend/lib/" . $className . ".php";
  // Check if file exists and is readable.
  if (is_readable($fileName)) {
    // Include the file.
    require $fileName;
  } 
}

// Register the autoloader function.
spl_autoload_register("standardAutoloadFunc");
</code></pre>
<p>The standard autoloader works as follows. Assuming that the class namespace 
can be mapped to the directory structure one-by-one, the function calculates 
the path to PHP file by transforming back-slashes (namespace separators) to 
forward slashes (path separators) and concatenating the resulting path with 
the absolute path to the directory where the library is located. Then the 
function checks if such a PHP file really exists, and if so, includes it 
with the <code>require</code> statement.</p>
<p>It is obvious, that the standard autoloader works slower than the class map autoloader.
However, its advantage is that you don't need to maintain any class map,
which is very convenient when you develop new code and add new classes to
your application.</p>
<blockquote class="notquote information" data-type="information"><p> Zend Framework 3 conforms to PSR-0 standard, making it possible to use standard 
 autoloading mechanism across all its components. It is also compatible with other
 PSR-0 conforming libraries like Doctrine or Symfony.</p>
</blockquote><h2 id="header-48">3.5. PSR-4 Standard</h2>
<p>The <a href="http://www.php-fig.org/psr/psr-4/">PSR-4 standard</a> is an extension to PSR-0. Its main addition is that you can define that a contiguous 
series of one or more leading namespace and sub-namespace names corresponds to a "base directory".
For example, if you have the <code>\Zend\Mvc\Application</code> fully qualified class name, and if you define that
the series <code>\Zend\Mvc\</code> corresponds to the "/path/to/zend/lib/" directory, you can organise
your files as follows:</p>
<pre class=""><code class="language-text">/path/to/zend/lib/
    Application.php
</code></pre>
<blockquote class="notquote information" data-type="information"><p> The advantage of PSR-4 is that you don't need to put your code in multiple nested directories,
as you would do with PSR-0. </p>
</blockquote><h2 id="header-49">3.6. Composer-provided Autoloader</h2>
<p>Zend Framework 3 uses the autoloader implementation provided by Composer. When you install a package with
Composer, it automatically creates the file <em>APP_DIR/vendor/autoloader.php</em>,
which uses the <code>spl_autoload_register()</code> PHP function to register an autoloader. This way all PHP classes
located in <code>APP_DIR/vendor</code> directory are correctly autoloaded.</p>
<p>To autoload PHP classes located in your own modules (like <code>Application</code> module), you'll have to specify
the <code>autoload</code> key in your <code>composer.json</code> file:</p>
<pre class=""><code class="language-json",title="Autoload key of composer.json file">"autoload": {
    "psr-4": {
        "Application\\": "module/Application/src/"
    }
},
</code></pre>
<p>Then the only thing need to be done is to include that file in your website entry script <code>index.php</code>:</p>
<pre class=""><code class="language-text">// Composer autoloading
include __DIR__ . '/../vendor/autoload.php';
</code></pre>
<h2 id="header-50">3.7. PSR-4 and Module's Source Directory Structure</h2>
<p>In Zend Skeleton Application, you can see how the PSR-4 standard is applied
in practice. For the default module of your website, the <code>Application</code> module, PHP classes which 
are registered with the standard autoloader are stored under the <code>APP_DIR/module/Application/src</code> 
directory ("src" abbreviation means "source"). </p>
<blockquote class="notquote information" data-type="information"><p> We will refer to the <code>src</code> directory as module's source directory.</p>
</blockquote><p>For example, lets look at the <code>IndexController.php</code> file of <code>Application</code> module (figure 3.2). </p>
<p><span class="image-wrapper">
<a target="_blank" href="images/operation/psr0_and_dir_structure.png">
<img src="images/operation/psr0_and_dir_structure.png" alt="Figure 3.2. Skeleton application's directory structure conforms to PSR-4 standard" /></a>
<span class="image-caption">Figure 3.2. Skeleton application's directory structure conforms to PSR-4 standard</span>
</span>
</p>
<p>As you can see, it contains the <code>IndexController</code> class <sup id="fnref:controller"><a href="#fn:controller" class="footnote-ref" rel="footnote">1</a></sup> belonging to <code>Application\Controller</code> namespace. 
To be able to follow the PSR-4 standard and use the standard autoloader with this PHP class, 
we have to put it under the <code>Controller</code> directory under the module's source 
directory. </p>
<footnotes id="fn:controller"><p><sup>1)</sup> <code>IndexController</code> class is the default controller for the skeleton website. 
We will talk about controllers later in chapter <a href="Model_View_Controller.html">Model-View-Controller</a>.</p>
</footnotes>
<h2 id="header-51">3.8. HTTP Request and Response</h2>
<p>When a site user opens a web page in a web browser's window, the browser generates
a request message and sends it using HTTP protocol to the web server. The web server
directs this HTTP request to your web application.</p>
<blockquote class="notquote information" data-type="information"><p> <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a> (stands for Hyper Text 
 Transfer Protocol) -- a protocol for transferring data 
 in the form of hyper text documents (web pages). HTTP is based on the client-server 
 technology: the client initiates a connection and sends a request to web server, and the 
 server waits for a connection, performs the necessary 
 actions and returns a response message back. </p>
</blockquote><p>Thus, the main underlying goal of any web application is handling the HTTP request 
and producing an HTTP response typically containing the HTML code of the requested web page. 
The response is sent by the web server to the client web browser and the browser displays a 
web page on the screen.</p>
<p>A typical HTTP request is presented below:</p>
<pre class="line-numbers"><code class="language-text",title="An HTTP request example">GET http://www.w3schools.com/ HTTP/1.1
Host: www.w3schools.com
Connection: keep-alive
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) 
Accept-Encoding: gzip,deflate,sdch
Accept-Language: en-US;q=0.8,en;q=0.6
Cookie: __gads=ID=42213729da4df8df:T=1368250765:S=ALNI_MaOAFe3U1T9Syh; 
(empty line)
(message body goes here)
</code></pre>
<p>The HTTP request message above consists of three parts:</p>
<ul>
<li>The starting line (line 1) specifies the method of the request (e.g GET or POST), the URL string
and HTTP protocol version.</li>
<li>Optional headers (lines 2-8) characterize the message, the transmission parameters and provide other meta information. 
In the example above, each row represents a single header in the form of <em>name:value</em>.</li>
<li>Optional message body contains message data. It is separated from the headers with a blank line.</li>
</ul>
<p>The headers and the message body may be absent, but the starting line is always 
present in the request, because it indicates its type and URL.</p>
<p>The server response for the above request is presented below:</p>
<pre class="line-numbers"><code class="language-text",title="An HTTP response example">HTTP/1.1 200 OK
Cache-Control: private
Content-Type: text/html
Content-Encoding: gzip
Vary: Accept-Encoding
Server: Microsoft-IIS/7.5
Set-Cookie: ASPSESSIONIDQQRBACTR=FOCCINICEFAMEKODNKIBFOJP; path=/
X-Powered-By: ASP.NET
Date: Sun, 04 Aug 2013 13:33:59 GMT
Content-Length: 8434
(empty line)
(page content follows)
</code></pre>
<p>As you can see from the dump above, the HTTP response has almost the same format as the request:</p>
<ul>
<li><p>The starting line (line 1) represents the HTTP protocol version, 
response status code and message (200 OK).</p>
</li>
<li><p>Optional headers (lines 2-10) provide various meta information about the response.</p>
</li>
<li><p>Optional message body follows the headers, and must be separated from headers 
by an empty line. The message body typically contains the HTML code of the requested 
web page.</p>
</li>
</ul>
<h2 id="header-52">3.9. Site Entry Script</h2>
<p>When the Apache web server receives an HTTP request from a client browser, 
it executes the <em>APP_DIR/public/index.php</em> file, also called the <em>entry script</em>. </p>
<blockquote class="notquote information" data-type="information"><p> The entry script is the only PHP file accessible to the outside world. Apache web server 
 directs all HTTP requests to this script (remember the <em>.htaccess</em> file?). Having this 
 single entry script makes the website more secure (comparing with the situation when you allow
 everyone to access all PHP files of your application). </p>
</blockquote><p>Although the <em>index.php</em> file is very important, it is surprisingly small (see below):</p>
<pre class="line-numbers"><code class="language-php">&lt;?php

use Zend\Mvc\Application;
use Zend\Stdlib\ArrayUtils;

/**
 * This makes our life easier when dealing with paths. Everything is relative
 * to the application root now.
 */
chdir(dirname(__DIR__));

// Decline static file requests back to the PHP built-in webserver
if (php_sapi_name() === 'cli-server') {
    $path = realpath(__DIR__ . parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH));
    if (__FILE__ !== $path &amp;&amp; is_file($path)) {
        return false;
    }
    unset($path);
}

// Composer autoloading
include __DIR__ . '/../vendor/autoload.php';

if (! class_exists(Application::class)) {
    throw new RuntimeException(
        "Unable to load application.\n"
        . "- Type `composer install` if you are developing locally.\n"
        . "- Type `vagrant ssh -c 'composer install'` if you are using Vagrant.\n"
        . "- Type `docker-compose run zf composer install` if you are using Docker.\n"
    );
}

// Retrieve configuration
$appConfig = require __DIR__ . '/../config/application.config.php';
if (file_exists(__DIR__ . '/../config/development.config.php')) {
    $appConfig = ArrayUtils::merge($appConfig, require __DIR__ . '/../config/development.config.php');
}

// Run the application!
Application::init($appConfig)-&gt;run();
</code></pre>
<p>Mainly, there are three things done in it.</p>
<p>First, in line 10, current working directory is changed to <code>APP_DIR</code>. 
This makes it simple to define relative file paths in your application.</p>
<p>Next, in line 22, PHP class autoloading is initialized. This allows to easily load any 
class either located in Zend Framework library or in your application without the need 
for <code>require_once</code> statement.</p>
<p>And finally, in line 40, an instance of <code>Zend\Mvc\Application</code> class is created.
The application is initialized with the settings read from <em>application.config.php</em> 
configuration file, and, the application is run.</p>
<h2 id="header-53">3.10. Events &amp; Application's Life Cycle</h2>
<p>As you've learned from the previous section, on every HTTP request, the <code>Zend\Mvc\Application</code> 
object is created. The application's "life" consists of several stages.</p>
<blockquote class="notquote information" data-type="information"><p> Zend Framework 3 uses the concept of <em>event</em>. One class can <em>trigger</em> an event,
 and other classes may <em>listen</em> to events. Technically, triggering an event means just calling
 another class' "callback" method. The event management is implemented inside of 
 the <code>Zend\EventManager</code> component.</p>
</blockquote><p>Each application life stage is initiated by the application by triggering an event. Other
classes (either belonging to Zend Framework or specific to your application) may listen 
to events and react accordingly.  </p>
<p>Below, the four main events (life stages) are presented:</p>
<p><strong>Bootstrap</strong>. When this event is triggered by the application, a module has a chance to
register itself as a listener of further application events in its <code>onBootstrap()</code> 
callback method.</p>
<p><strong>Route</strong>. When this event is triggered, the request's URL is analyzed using a <em>router</em> class (typically, with 
<code>Zend\Router\Http\TreeRouteStack</code> class. If an exact match between the URL and a route
is found, the request is passed to the site-specific <em>controller</em> class assigned to the route.</p>
<p><strong>Dispatch</strong>. The controller class "dispatches" the request using the corresponding action method 
and produces the data that can be displayed on the web page. </p>
<p><strong>Render</strong>. On this event, the data produced by the controller's action method are passed for rendering to 
<code>Zend\View\Renderer\PhpRenderer</code> class. The renderer class uses a 
<em>view template</em> file for producing an HTML page.</p>
<p>The event flow is illustrated in figure 3.3:</p>
<p><span class="image-wrapper">
<a target="_blank" href="images/operation/app_life_cycle.png">
<img src="images/operation/app_life_cycle.png" alt="Figure 3.3. Event flow during the application's life cycle" /></a>
<span class="image-caption">Figure 3.3. Event flow during the application's life cycle</span>
</span>
</p>
<h2 id="header-54">3.11. Application Configuration</h2>
<p>Most of Zend Framework components which are used in your website, 
require configuration (fine-tuning). For example, in the configuration 
file you define database connection credentials, specify which modules 
are present in your application, and, optionally, provide some custom 
parameters specific to your application.</p>
<p>You can define the configuration parameters in two levels: either at the 
application level, or at the module level. At the application level you typically 
define parameters which control the whole app and are common to all 
modules of your application. At the module level, you define parameters which
affect only this module. </p>
<blockquote class="notquote information" data-type="information"><p> Some PHP frameworks prefer <em>conventions over configuration</em> concept, where
 most of your parameters are hard-coded and do not require configuration.
 This makes it faster to develop the application, but makes it less customizable.
 In Zend Framework 3, the <em>configuration over conventions</em> concept is used,
 so you can customize any aspect of your application, but have to
 spend some time for learning how to do that.</p>
</blockquote><h3 id="header-55">3.11.1. Application-Level Config Files</h3>
<p>The <em>APP_DIR/config</em> subdirectory contains application-wide configuration files. Let's look
at this subdirectory in more details (figure 3.4).</p>
<p><span class="image-wrapper">
<a target="_blank" href="images/operation/config.png">
<img src="images/operation/config.png" alt="Figure 3.4. Configuration files" /></a>
<span class="image-caption">Figure 3.4. Configuration files</span>
</span>
</p>
<p>The <em>APP_DIR/config/application.config.php</em> file is the main configuration file.
It is used by the application on start up for determining which application modules should be loaded
and which services to create by default.</p>
<p>Below, a starting fragment of <em>application.config.file</em>
is presented. You can see that the configuration file is just a usual 
PHP nested associative array, and each component
may have a specific key in that array. You can provide inline comments for the array keys
to make it easier for others to understand what each key means. </p>
<blockquote class="notquote tip" data-type="tip"><p> By convention, key names should be in lower case, and if the key name consists 
 of several words, the words should be separated by the underscore symbol ('_').</p>
</blockquote><pre class="line-numbers"><code class="language-php">return [
    // Retrieve list of modules used in this application.
    'modules' =&gt; require __DIR__ . '/modules.config.php',

    // These are various options for the listeners attached to the ModuleManager
    'module_listener_options' =&gt; [
        // This should be an array of paths in which modules reside.
        // If a string key is provided, the listener will consider that a module
        // namespace, the value of that key the specific path to that module's
        // Module class.
        'module_paths' =&gt; [
            './module',
            './vendor',
        ],

        // An array of paths from which to glob configuration files after
        // modules are loaded. These effectively override configuration
        // provided by modules themselves. Paths may use GLOB_BRACE notation.
        'config_glob_paths' =&gt; [
            realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php',
        ],

        // Whether or not to enable a configuration cache.
        // If enabled, the merged configuration will be cached and used in
        // subsequent requests.
        'config_cache_enabled' =&gt; true,

        // The key used to create the configuration cache file name.
        'config_cache_key' =&gt; 'application.config.cache',

        // Whether or not to enable a module class map cache.
        // If enabled, creates a module class map cache which will be used
        // by in future requests, to reduce the autoloading process.
        'module_map_cache_enabled' =&gt; true,

        // The key used to create the class map cache file name.
        'module_map_cache_key' =&gt; 'application.module.cache',

        // The path in which to cache merged configuration.
        'cache_dir' =&gt; 'data/cache/',

        // Whether or not to enable modules dependency checking.
        // Enabled by default, prevents usage of modules that depend on other modules
        // that weren't loaded.
        // 'check_dependencies' =&gt; true,
    ],

    // Used to create an own service manager. May contain one or more child arrays.
    //'service_listener_options' =&gt; [
    //     [
    //         'service_manager' =&gt; $stringServiceManagerName,
    //         'config_key'      =&gt; $stringConfigKey,
    //         'interface'       =&gt; $stringOptionalInterface,
    //         'method'          =&gt; $stringRequiredMethodName,
    //     ],
    // ],

   // Initial configuration with which to seed the ServiceManager.
   // Should be compatible with Zend\ServiceManager\Config.
   // 'service_manager' =&gt; [],
];
</code></pre>
<p>In line 3 we have the <em>modules</em> key defining which modules will be loaded on start up. You can see that
the module names are stored inside of another config file <code>modules.config.php</code>, which lists all modules 
present in your website. </p>
<p>In line 11, there is the <code>module_paths</code> key which tells ZF3 about
directories where to look for source files belonging to modules. Application modules
that you develop are located under <em>APP_DIR/module</em> directory, and third-party 
modules may be located inside the <em>APP_DIR/vendor</em> directory.</p>
<p>And in line 19 we have the <code>config_glob_paths</code> key, which tells ZF3 where to
look for extra config files. You see that files from <em>APP_DIR/config/autoload</em>
which have <em>global.php</em> or <em>local.php</em> suffix, are automatically loaded.</p>
<p>Summing up, you typically use the main <em>application.config.php</em> file for storing the information 
about which modules should be loaded into your app and where they are located and
how they are loaded (for example, you can control caching options here). In this
file you can also tune the service manager. It is not recommended to add more
keys in this file. For that purpose it is better to use <code>autoload/global.php</code> file.</p>
<p>And let's also look inside the <code>modules.config.php</code> file. Currently, you have the following modules
installed in your website:</p>
<pre class=""><code class="language-php">return [
    'Zend\Session',
    'Zend\Mvc\Plugin\Prg',
    'Zend\Mvc\Plugin\Identity',
    'Zend\Mvc\Plugin\FlashMessenger',
    'Zend\Mvc\Plugin\FilePrg',
    'Zend\Form',
    'Zend\Router',
    'Zend\Validator',
    'Application',
];
</code></pre>
<p>The <code>Application</code> module is a module containing your app's files. All other modules listed are Zend Framework
components.</p>
<blockquote class="notquote information" data-type="information"><p> In ZF3, a special Composer plugin called <em>component installer</em> was introduced. If you remember, in the
chapter <a href="Zend_Skeleton_Application.html">Zend Skeleton Application</a>, we answered several yes/no questions of the installer, determining
which components to install. And the installer <em>injected</em> those components' module names here, in <code>modules.config.php</code></p>
</blockquote><h3 id="header-56">3.11.2. Application-Level Extra Config Files</h3>
<p>"Extra" config files, <em>APP_DIR/config/autoload/global.php</em> and <em>APP_DIR/config/autoload/local.php</em>
files define application-wide environment-agnostic and environment-dependent parameters, respectively.
These config files are automatically loaded and recursively merged with the module-provided config files,
that's why their directory is named <em>autoload</em>.</p>
<p>Having different config files in <em>APP_DIR/config/autoload</em> directory, you might have been 
confused about which parameters should be put into each one. Here are some hints:</p>
<ul>
<li><p>You use the <em>autoload/global.php</em> file for storing parameters which do not depend
on the concrete machine environment. For example, here you can store parameters which 
override the default parameters of some module. Do not store sensitive information 
(like database credentials) here, for that purpose it's better to use <em>autoload/local.php</em>.</p>
</li>
<li><p>You use the <em>autoload/local.php</em> file for storing parameters specific to the
concrete environment. For example, here you can store your database credentials.
Each developer usually has a local database when developing and testing the website. 
The developer thus will edit the <em>local.php</em> file and enter his own database credentials here.
When you install your site to the production server, you will edit the <code>local.php</code> file and enter
the credentials for the "live" database here.</p>
</li>
</ul>
<blockquote class="notquote information" data-type="information"><p> Because the <em>autoload/local.php</em> file contains environment-specific parameters, 
 in version control system you store its "distribution template" <em>local.php.dist</em>.
 Each developer in your team then renames the <em>local.php.dist</em> file into <em>local.php</em> and
 enters his own parameters. This <em>local.php</em> file should not be stored under
 version control, because it may contain sensitive information like database credentials 
 (username and password), and you might want that other people do not see these.     </p>
</blockquote><h3 id="header-57">3.11.3. Application-Level Development Config File</h3>
<p>The application-level development configuration file (<code>APP_DIR/config/development.config.php</code>) presents only
when you enable the <em>development mode</em>. If you remember, we enabled the development mode earlier in the <a href="Zend_Skeleton_Application.html">Zend Skeleton Application</a> chapter.</p>
<blockquote class="notquote information" data-type="information"><p> You enable the development mode with the following command:</p>
<p> <code>php composer.phar development-enable</code></p>
</blockquote><p>The <code>development.config.php</code> file is merged with the main <code>application.config.php</code> file. This allows you to
override some parameters. For example, you can:</p>
<ul>
<li>disable config caching. When you develop your website, you frequently modify your config files, so config caching
may have undesired consequences, like inability to see the result of your changes immediately.</li>
<li>load additional modules. For example, you can load <a href="https://github.com/zendframework/ZendDeveloperTools">ZendDeveloperTools</a> module only in development mode.   </li>
</ul>
<p>If you disable the development mode, the <code>development.config.php</code> file will be removed. So, you should not
store this file under the version control. Instead, store its <em>distribution</em> version, <code>development.config.php.dist</code> under version control.</p>
<h3 id="header-58">3.11.4. Module-Level Config Files</h3>
<p>In figure 3.4, you could see that the <em>Application</em> module shipped with your application
has the <em>module.config.php</em> file, in which you put your module-specific parameters. Let's 
look at <code>module.config.php</code> file of the <code>Application</code> module:</p>
<pre class=""><code class="language-php">&lt;?php
namespace Application;

use Zend\Router\Http\Literal;
use Zend\Router\Http\Segment;
use Zend\ServiceManager\Factory\InvokableFactory;

return [
    'router' =&gt; [
        'routes' =&gt; [
            'home' =&gt; [
                'type' =&gt; Literal::class,
                'options' =&gt; [
                    'route'    =&gt; '/',
                    'defaults' =&gt; [
                        'controller' =&gt; Controller\IndexController::class,
                        'action'     =&gt; 'index',
                    ],
                ],
            ],
            'application' =&gt; [
                'type'    =&gt; Segment::class,
                'options' =&gt; [
                    'route'    =&gt; '/application[/:action]',
                    'defaults' =&gt; [
                        'controller'    =&gt; Controller\IndexController::class,
                        'action'        =&gt; 'index',
                    ],
                ],
            ],
        ],
    ],
    'controllers' =&gt; [
        'factories' =&gt; [
            Controller\IndexController::class =&gt; InvokableFactory::class,
        ],
    ],
    'view_manager' =&gt; [
        'display_not_found_reason' =&gt; true,
        'display_exceptions'       =&gt; true,
        'doctype'                  =&gt; 'HTML5',
        'not_found_template'       =&gt; 'error/404',
        'exception_template'       =&gt; 'error/index',
        'template_map' =&gt; [
            'layout/layout'           =&gt; __DIR__ . '/../view/layout/layout.phtml',
            'application/index/index' =&gt; __DIR__ . '/../view/application/index/index.phtml',
            'error/404'               =&gt; __DIR__ . '/../view/error/404.phtml',
            'error/index'             =&gt; __DIR__ . '/../view/error/index.phtml',
        ],
        'template_path_stack' =&gt; [
            __DIR__ . '/../view',
        ],
    ],
];
</code></pre>
<p>In this file, you register the module's controllers, put information about routing rules 
for mapping URLs to your controllers, register controller plugins, and also register view templates 
and view helpers (we will learn more about these terms in this chapter and in the next chapters).</p>
<h3 id="header-59">3.11.5. Combining the Configuration Files</h3>
<p>When an application is being created, module-provided configuration files and extra configuration files from
<em>APP_DIR/config/autoload</em> directory are being merged into one big nested array, 
so every configuration parameter becomes available to any piece of the website. 
So, potentially, you are able to override some parameters specified by the modules.        </p>
<blockquote class="notquote information" data-type="information"><p> You might also have seen the "combined" config file when installing PHP, where there is
 the main <em>php.ini</em> file and several extra config files, which are included into the main one.
 Such a separation makes your application configuration fine-grained and flexible, 
 because you don't have to put all your params to a single file and edit it each time you need
 to change something.</p>
</blockquote><p>The configuration files are loaded in the following order:</p>
<ul>
<li><p>The main <em>application.config.php</em> file is loaded first. It is used to initialize the
service manager and load application modules. The data loaded from this config
is stored alone and not merged with other config files.</p>
</li>
<li><p>Configuration files for each application module are loaded and merged. Modules
are loaded in the same order as they are listed in the <em>application.config.php</em> file.
If two modules store (either intentionally, or by mistake) parameters in the 
similar-named keys, these parameters may be overwritten.</p>
</li>
<li><p>Extra config files from the <em>APP_DIR/config/autoload</em> folder are loaded and merged into a
single array.   Then this array is merged with the module config array produced on the previous 
stage, when loading the module configuration. Application-wide configuration has 
higher priority than the module configuration, so you can override module keys here, 
if you wish.  </p>
</li>
</ul>
<h2 id="header-60">3.12. Module Entry Point</h2>
<p>Each module of the web application has the <em>Module.php</em> file which is some kind 
of <em>entry point</em> for the module. This file provides the <code>Module</code> class. Below, the contents 
of skeleton application's <code>Module</code> class
is presented:</p>
<pre class="line-numbers"><code class="language-php">&lt;?php 
namespace Application;

class Module
{
    const VERSION = '3.0.0dev';

    public function getConfig()
    {
        return include __DIR__ . '/../config/module.config.php';
    }
}
</code></pre>
<p>The class <code>Module</code> belongs to the module's namespace (for the main module
it belongs to the <code>Application</code> namespace).</p>
<p>The <code>getConfig()</code> method (lines 16-19) tells the Zend Framework where the 
<em>module.config.php</em> file is located.</p>
<blockquote class="notquote information" data-type="information"><p> You can also register some <em>event listeners</em> here, we'll see how to do this later.</p>
</blockquote><h2 id="header-61">3.13. Service Manager</h2>
<p>You can imagine the web application as a set of <em>services</em>. For example,
you can have an authentication service responsible for logging in the site users, 
entity manager service responsible for accessing the database, event manager service 
responsible for triggering events and delivering them to event listeners, etc.</p>
<p>In Zend Framework, the <code>ServiceManager</code> class is a centralized repository for all 
application services. The service manager is implemented in <code>Zend\ServiceManager</code> 
component, as the <code>ServiceManager</code> class. </p>
<p>The service manager is created on application start up (inside of <code>init()</code>
static method of <code>Zend\Mvc\Application</code> class).
The standard services available through service manager are presented in table 3.1. 
This table is incomplete, because the actual number of services registered in service manager 
may be much bigger.</p>
<div class="table-wrapper">
<div class="table-caption">Table 3.1. Standard services</div><table>
<thead>
<tr>
<th> Service Name         </th>
<th> Description                                                           </th>
</tr>
</thead>
<tbody>
<tr>
<td>  Application          </td>
<td>  Allows to retrieve the singleton of <code>Zend\Mvc\Application</code> class.     </td>
</tr>
<tr>
<td> ApplicationConfig    </td>
<td> Configuration array extracted from <em>application.config.php</em> file.     </td>
</tr>
<tr>
<td> Config                                      </td>
<td> Merged configuration array extracted from <em>module.config.php</em> files     merged with <em>autoload/global.php</em> and <em>autoload/local.php</em>.           </td>
</tr>
<tr>
<td> EventManager                                </td>
<td> Allows to retrieve the singleton of <code>Zend\Mvc\EventManager</code> class. The    event manager allows to send (trigger) events and attach event listeners. </td>
</tr>
<tr>
<td> ModuleManager                               </td>
<td> Allows to retrieve the singleton of <code>Zend\Mvc\ModuleManager</code> class. The   module manager is responsible for loading application modules.        </td>
</tr>
<tr>
<td> Request                                     </td>
<td> The singleton of <code>Zend\Http\Request</code> class. Represents HTTP request     received from client.                                                 </td>
</tr>
<tr>
<td> Response                                    </td>
<td> The singleton of <code>Zend\Http\Response</code> class. Represents HTTP response that    will be sent to client.                                               </td>
</tr>
<tr>
<td> Router               </td>
<td> The singleton of <code>Zend\Router\Http\TreeRouteStack</code>. Performs URL routing. </td>
</tr>
<tr>
<td> ServiceManager       </td>
<td> Service manager itself.                                               </td>
</tr>
<tr>
<td> ViewManager                                 </td>
<td> The singleton of <code>Zend\Mvc\View\Http\ViewManager</code> class. Responsible for      preparing the view layer for page rendering.                               </td>
</tr>
</tbody>
</table>
</div>
<p>A service is typically an arbitrary PHP class, but not always. For example, when ZF3
loads the configuration files and merges the data into nested arrays, it saves the arrays 
in the service manager as a couple of services (!): <code>ApplicationConfig</code> and <code>Config</code>. 
The first one is the array loaded from application-level configuration file <em>application.config.php</em>,
and the later one is the merged array from module-level config files and auto-loaded 
application-level config files. Thus, in the service manager you can store any asset 
you want: a PHP class, a variable or an array.</p>
<p>From table 3.1, you can see that in ZF3 everything can be considered as a service. The service 
manager is itself registered as a service. Moreover, the <code>Application</code> class is also 
registered as a service.  </p>
<blockquote class="notquote information" data-type="information"><p> An important thing you should note about the services is that they are typically 
 stored in a single instance only (this is also called the <em>singleton</em> pattern). Obviously,
 you don't need the second instance of the <code>Application</code> class or, say, the event manager (in that case you
 would have a nightmare). </p>
</blockquote><p>The service manager defines the methods needed for locating and retrieving 
a service from the service manager:</p>
<pre class=""><code class="language-php">// Retrieves a registered service's instance.
public function get($name);

// Checks if such a service is registered.
public function has($name);
</code></pre>
<p>You can test if a service is registered by passing its name to the service manager's 
<code>has()</code> method. It returns a boolean <code>true</code> if the service is registered, or
<code>false</code> if the service with such a name is not registered.</p>
<p>You can retrieve a service by its name at any place of your 
application with the help of the service manager's <code>get()</code> method. This method
takes a single parameter representing the service name. Look at the following
example:</p>
<pre class=""><code class="language-php">&lt;?php 

// Retrieve the application config array.
$appConfig = $serviceManager-&gt;get('ApplicationConfig');

// Use it (for example, retrieve the module list).
$modules = $appConfig['modules'];
</code></pre>
<h3 id="header-62">3.13.1. Service Names</h3>
<p>Different services can use different naming styles. For example, the same currency converter service 
may be registered under the different names: <code>CurrencyConverter</code>,  <code>currency_converter</code> 
and so on. To introduce some uniform naming convention, it is recommended to register a service by
its fully qualified class name, as follows:</p>
<pre class=""><code class="language-text">$serviceManager-&gt;setService(CurrencyConverter::class);
</code></pre>
<p>In the example above, we used the keyword <code>class</code>. It is available since PHP 5.5 and is used for class 
name resolution. <code>CurrencyConverter::class</code> is expanded to the fully qualified name of the class, 
like <code>\Application\Service\CurrencyConverter</code>.</p>
<h3 id="header-63">3.13.2. Registering a Service</h3>
<p>When writing your website, sometimes you will need to register your custom service
in the service manager. To register a service, you use the <code>setService()</code> method.
Let's create and register the currency converter service class, which
will be used, for example, on a shopping cart page to convert EUR currency to USD:</p>
<pre class="line-numbers"><code class="language-php">&lt;?php 
// Define a namespace where our custom service lives.
namespace Application\Service;

// Define a currency converter service class.
class CurrencyConverter 
{
  // Converts euros to US dollars.
  public function convertEURtoUSD($amount) 
  {
    return $amount*1.25;
  }
	
  //...
}
</code></pre>
<p>Above, in lines 6-15 we define an example <code>CurrencyConverter</code> class (for simplicity, we implement
only a single method <code>convertEURtoUSD()</code> which is able to convert euros to US dollars).</p>
<pre class=""><code class="language-php">// Create an instance of the class.
$service = new CurrencyConverter();
// Save the instance to service manager.
$serviceManager-&gt;setService(CurrencyConverter::class, $service);
</code></pre>
<p>In the example above, we instantiate the class with the <code>new</code> operator, and register it
with the service manager using the <code>setService()</code> method (we assume that the <code>$serviceManager</code> variable
is of type <code>Zend\ServiceManager\ServiceManager</code> class, and that it was declared somewhere else). </p>
<p>The <code>setService()</code> method takes two parameters: the service name string, and the service instance.
The service name should be unique within all other possible services. If you are trying to register
the service name which is already present, the <code>setService()</code> method will throw an exception. But sometimes
you want to override the service with the same name (to replace it by the new one). For this purpose,
you can use the <code>setAllowOverride()</code> method of the service manager:</p>
<pre class=""><code class="language-php">&lt;?php 
// Allow to replace services 
$serviceManager-&gt;setAllowOverride(true);

// Save the instance to service manager. There will be no exception
// even if there is another service with such a name.
$serviceManager-&gt;setService(CurrencyConverter::class, $service);
</code></pre>
<p>Above, the <code>setAllowOverride()</code> method takes the single boolean parameter defining whether
to allow you replace the service <code>CurrencyConverter</code> if such a name is already present, or not.</p>
<p>Once the service is stored in service manager, you can retrieve it by name at any place of your 
application with the help of the service manager's <code>get()</code> method. Look at the following
example:</p>
<pre class=""><code class="language-php">&lt;?php 
// Retrieve the currency converter service.
$service = $serviceManager-&gt;get(CurrencyConverter::class);

// Use it (convert money amount).
$convertedAmount = $service-&gt;convertEURtoUSD(50);
</code></pre>
<h3 id="header-64">3.13.3. Registering Invokable Classes</h3>
<p>What is bad with the <code>setService()</code> method is that you have to create the service instance
before you really need it. If you never use the service, the service instantiation will only
waste the time and memory. To resolve this issue, the service manager provides you with the 
<code>setInvokableClass()</code> method.</p>
<pre class=""><code class="language-php">&lt;?php 
// Register an invokable class
$serviceManager-&gt;setInvokableClass(CurrencyConverter::class);
</code></pre>
<p>In the example above, we pass to the service manager the fully qualified class name of
the service instead of passing its instance. With this technique, the service
will be instantiated by the service manager only when someone calls the <code>get(CurrencyConverter::class)</code>
method. This is also called lazy loading.</p>
<h3 id="header-65">3.13.4. Registering Factories</h3>
<p>Sometimes, service instantiation is more complex than just creating the service instance
with <code>new</code> operator. You may need to pass some parameters to the service's constructor or
invoke some service methods just after construction. This complex instantiation logics
can be encapsulated inside of a <em>factory</em>. A factory is a PHP class responsible for creating
new objects. The factory class typically implements the <code>FactoryInterface</code>:</p>
<pre class=""><code class="language-php">&lt;?php
namespace Zend\ServiceManager\Factory;

use Interop\Container\ContainerInterface;

interface FactoryInterface
{
    public function __invoke(ContainerInterface $container, $requestedName, array $options = null);
}
</code></pre>
<p>As we see from the definition of the <code>FactoryInterface</code>, the factory class must provide
the <code>__invoke</code> magic method returning the instance of a single service. The service manager is
passed to the <code>__invoke</code> method as the <code>$container</code> parameter; it can be used during the construction of 
the service for accessing other services (to inject <em>dependencies</em>).</p>
<p>As an example, let's write a factory for our currency converter service (see the code below). 
We don't use complex construction logics for our <code>CurrencyConverter</code> service, but for more complex 
services, you may need to use one.</p>
<pre class=""><code class="language-php">&lt;?php 
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\CurrencyConverter;

// Factory class
class CurrencyConverterFactory implements FactoryInterface{

  public function __invoke(ContainerInterface $container, $requestedName, array $options = null) 
  {
    // Create an instance of the class.
    $service = new CurrencyConverter();	
	
    return $service;
  }
}
</code></pre>
<p>Even more complex case of a factory is when you need to determine at run
time which services should be registered, and which should not. For such a situation,
you can use an <em>abstract factory</em>. An abstract factory class should
implement the <code>AbstractFactoryInterface</code> interface:</p>
<pre class=""><code class="language-php">&lt;?php 
namespace Zend\ServiceManager\Factory;

use Interop\Container\ContainerInterface;

interface AbstractFactoryInterface extends FactoryInterface
{
    public function canCreate(ContainerInterface $container, $requestedName);
}
</code></pre>
<p>The <code>AbstractFactoryInterface</code> interface has two methods: <code>canCreate()</code>
and <code>__invoke()</code>. The first one is needed to test if the factory can
create the service with the certain name, and the latter one allows to actually
create the service. The methods take two parameters: service manager and
service name.</p>
<p>Comparing to usual factory class, the difference is that the
usual factory class can create only a single service, but an abstract factory can dynamically 
create as many services as it wants.</p>
<h3 id="header-66">3.13.5. Registering Service Aliases</h3>
<p>Sometimes, you may want to define an <em>alias</em> for a service. The alias 
is like a symbolic link: it references the already registered service.
To create an alias, you use the service manager's <code>setAlias()</code> method:</p>
<pre class=""><code class="language-php">&lt;?php 
// Register an alias for the CurrencyConverter service
$serviceManager-&gt;setAlias('CurConv', CurrencyConverter::class);
</code></pre>
<p>Once registered, you can retrieve the service by both its name and alias using the 
service manager's <code>get()</code> method.</p>
<h3 id="header-67">3.13.6. Service Manager Configuration</h3>
<p>To automatically register a service within the service manager, typically the
<code>service_manager</code> key of a configuration file is used. You can put this key
either inside of an application-level configuration file or in a module-level 
configuration file. </p>
<blockquote class="notquote warning" data-type="warning"><p> If you are putting this key in a module-level configuration file, be
 careful about the danger of name overwriting during the configs merge.
 Do not register the same service name in different modules.</p>
</blockquote><p>This <code>service_manager</code> key should look like below:</p>
<pre class="line-numbers"><code class="language-php">&lt;?php 
return [
  //...

  // Register the services under this key
  'service_manager' =&gt; [
    'services' =&gt; [
      // Register service class instances here
      //...
    ],
    'invokables' =&gt; [
      // Register invokable classes here
      //...
    ],
    'factories' =&gt; [
      // Register factories here
      //...
    ],
    'abstract_factories' =&gt; [
      // Register abstract factories here
      //...
    ],
    'aliases' =&gt; [
      // Register service aliases here
      //...
    ],
  ],
  
  //...
];
</code></pre>
<p>In the example above, you can see that the <code>service_manager</code> key may contain several
subkeys for registering services in different ways:</p>
<ul>
<li>the <code>services</code> subkey (line 7) allows to register class instances;</li>
<li>the <code>invokables</code> subkey (line 11) allows to register full class name of a service;
the service will be instantiated using lazy loading;</li>
<li>the <code>factories</code> subkey (line 15) allows for registering a factory, which is able
to create instances of a single service;</li>
<li>the <code>abstract_factories</code> (line 19) can be used for registering abstract factories,
which are able to register several services by name;</li>
<li>the <code>aliases</code> subkey (line 23) provides an ability to register an alias for a service.</li>
</ul>
<h2 id="header-68">3.14. Summary</h2>
<p>In this chapter, we've learned some theory about ZF3-based website operation basics.</p>
<p>ZF3 uses PHP namespaces and class autoloading features, simplifying the development
of applications which use many third-party components. The namespaces allow to solve the 
name collisions between code components, and provide you with the ability to make the long names shorter. </p>
<p>The class autoloading makes it possible to use any PHP class in any library installed with Composer 
without the use of <code>require_once</code> statement. Composer also provides a PSR-4 autoloader for the classes
located in the modules of your web application.</p>
<p>Most of Zend Framework 3 components require configuration. You can define the configuration parameters either at 
the application level, or at the module level. </p>
<p>The main goal of any web application is handling the HTTP request and producing an 
HTTP response typically containing the HTML code of the requested web page. When 
Apache web server receives an HTTP request from a client browser, it executes the <em>index.php</em> 
file, which is also called the site's entry script. On every HTTP request, the <code>Zend\Mvc\Application</code> 
object is created, whose "life cycle" consists of several stages (or events).</p>
<p>The web application's business logic can be also considered as a set of services. In Zend Framework 3, 
the service manager is a centralized repository for all the application services. A service is typically
a PHP class, but in general it can be a variable or an array, if needed.</p>
        
</div>

<!-- Ads -->
<div id="ads-chapter-bottom">
<div>
ï»¿<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Using Zend Framework 3 Chapter - Bottom - Adaptive -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3933778336056438"
     data-ad-slot="1546211126"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
</div>
    
<!-- Navigation -->
<div class="navigation">
    <div class="prev-chapter">
        
        <a href="Zend_Skeleton_Application.html">
            <img alt="Previous Chapter" src="../assets/images/left.png"><span class="nav-btn-text">Previous</span>
        </a>
        </div>    
    <div class="contents">
        <a href="toc.html">
            <img alt="Contents" src="../assets/images/book.png"><span class="nav-btn-text">Contents</span>
        </a>
    </div>
    <div class="next-chapter">
                <a href="Model_View_Controller.html">
            <span class="nav-btn-text">Next</span><img alt="Next Chapter" src="../assets/images/right.png">
        </a>
            </div>    
</div>

<div id="disqus_thread"></div>

        
</div>
<footer>
    <div class="footer">
        <div class="footer-body">
            <div class="copyright">
                Copyright (c) 2016 by Oleg Krivtsov            </div>
            <div class="generated-by">
                Generated using <a href="https://github.com/olegkrivtsov/openbook">OpenBook</a> on 2016-08-25 at 02:41            </div>
        </div>    
    </div>
</footer>

<a href="#0" class="cd-top">Top</a>

<script src="../assets/js/jquery.min.js"></script>
<script src="../assets/js/loadCSS.js"></script>

<script src="../assets/js/prism.js"></script>

<script>
var disqus_config = function () {
this.page.url = window.location.href; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//using-zend-framework-3-book.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script>
loadCSS("../assets/css/prism.css");
</script>

<script>
jQuery(document).ready(function($){
    // browser window scroll (in pixels) after which the "back to top" link is shown
    var offset = 300,
    //browser window scroll (in pixels) after which the "back to top" link opacity is reduced
    offset_opacity = 1200,
    //duration of the top scrolling animation (in ms)
    scroll_top_duration = 700,
    //grab the "back to top" link
    $back_to_top = $('.cd-top');

    //hide or show the "back to top" link
    $(window).scroll(function(){
            ( $(this).scrollTop() > offset ) ? $back_to_top.addClass('cd-is-visible') : $back_to_top.removeClass('cd-is-visible cd-fade-out');
            if( $(this).scrollTop() > offset_opacity ) { 
                    $back_to_top.addClass('cd-fade-out');
            }
    });

    //smooth scroll to top
    $back_to_top.on('click', function(event){
            event.preventDefault();
            $('body,html').animate({
                    scrollTop: 0 ,
                    }, scroll_top_duration
            );
    });

});
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-80824388-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>    

