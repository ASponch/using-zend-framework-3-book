## Controllers

A controller provides communication between the application, models and views: 
gets input from HTTP request and uses the model(s) and the corresponding view 
to produce the necessary HTTP response.

Controllers belonging to module typically reside in the `Controller` subdirectory 
of module's source directory (shown in figure 4.3).

![Figure 4.3. Controller directory](images/mvc/controller_dir.png)

Zend Skeleton Application provides you with the default implementation of `IndexController` 
class. The `IndexController` is typically the main controller class of the web site. Its code 
is presented below (some parts of code were omitted for simplicity):  

{line-numbers=on,lang=php}
~~~
<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;

class IndexController extends AbstractActionController
{
    public function indexAction()
    {
        return new ViewModel();
    }
}
~~~

From the example above, you can see that controllers usually define their own namespace (line 3). 
The Index controller, as all other controllers from the *Application* module, lives in `Application\Controller` 
namespace.

A controller is a usual PHP class derived from the `AbstractActionController` base class (line 8). 

By default, the controller class contains the single *action method* called `indexAction()` (see lines 11-14).
Typically, you will create other action methods in your controller classes. 

T> ZF3 automatically recognizes the action methods by the `Action` suffix. 
T> If a controller method's name does not have that suffix, it is considered as a usual method, not an action.

As its name assumes, an action method performs some site action, 
which typically results in producing a single web page. Index controller usually
contains action methods for site-wide web pages (table 4.1). For example, you would have 
"index" action for the *Home* page, "about" action for *About* page,
"contactUs" action for the *Contact Us* page and possibly other actions.

{title="Table 4.1. Index controller's typical actions"}
|------------------------------------|--------------------------------------------------|
| *Action Method*                    | *Description*                                    |
|------------------------------------|--------------------------------------------------|
| `IndexController::indexAction()`   | The "index" action displays the Home page of your| 
|                                    | site.                                            |
|------------------------------------|--------------------------------------------------|
| `IndexController::aboutAction()`   | The "about" action displays the About page of    |
|                                    | the site. The About page contains contact and    |
|                                    | copyright information.                           |
|------------------------------------|--------------------------------------------------|
| `IndexController::contactUsAction()`| The "contactUs" action displays the Contact Us   |
|                                    | page of the site. The Contact Us page displays   |
|                                    | the form for contacting site authors.            |
|------------------------------------|--------------------------------------------------|

### Base Controller Class

Every controller in your web site is inherited from the `AbstractActionController` base class.
In figure 4.4, the class inheritance diagram is presented.

![Figure 4.4. Controller inheritance diagram](images/mvc/controller_inheritance.png)

The `AbstractActionController` provides you with several useful methods you can use
in your controller classes. Table 4.2 provides you with a brief summary of the methods:

{title="Table 4.2. AbstractActionController's useful methods"}
|----------------------------------|--------------------------------------------------------|
| *Method Name*                    | *Description*                                          |
|----------------------------------|--------------------------------------------------------|
| `getRequest()`                   | Retrieves the `Zend\Http\Request` object, which is the |
|                                  | representation of HTTP request data.                   |
|----------------------------------|--------------------------------------------------------|
| `getResponse()`                  | Retrieves the `Zend\Http\PhpEnvironment\Response` object|
|                                  | allowing to set data of HTTP response.                 |
|----------------------------------|--------------------------------------------------------|
| `getEventManager()`              | Returns the `Zend\EventManager\EventManager` object,   |
|                                  | allowing to trigger events and listen to events.       |
|----------------------------------|--------------------------------------------------------|
| `getEvent()`                     | Returns the `Zend\Mvc\MvcEvent` object, which represents|
|                                  | the event the controller responds to.                  |
|----------------------------------|--------------------------------------------------------|
| `getPluginManager()`             | Returns the `Zend\Mvc\Controller\PluginManager` object,|
|                                  | which can be used for registering controller plugins.  |
|----------------------------------|--------------------------------------------------------|
| `plugin($name, $options)`        | This method allows to access certain controller  plugin|
|                                  | with the given name.                                   |
|----------------------------------|--------------------------------------------------------|
| `__call($method, $params)`       | Allows to call a plugin indirectly using the PHP `__call` |
|                                  | magic method.                                          |
|----------------------------------|--------------------------------------------------------|

As you can see from the table above, the base controller class provides you with access to HTTP request
and response data, and provides you with the access to the event manager.
It also gives you an ability to register and call controller plugins (we will learn about controller
plugins later in this chapter).

### Retrieving Data from HTTP Request

In a controller's action method, you may need to retrieve the data from the HTTP request 
(the data like GET and POST variables, cookies, HTTP headers and so on). For this purpose, Zend Framework 3 
provides you with `Zend\Http\Request` and `Zend\Http\PhpEnvironment\Response` classes, 
which are part of `Zend\Http` component.

To get the HTTP request object, inside of your action method, you can use the following code:

{line-numbers=off,lang=php}
~~~
// Get HTTP request object
$request = $this->getRequest();
~~~

The code above returns the instance of `Zend\Http\Request` class, containing all the HTTP 
request data. In table 4.3, you can find the most widely used methods of the `Request` class together 
with their brief description.

{title="Table 4.3. Methods of `Zend\Http\Request` class."}
|----------------------------------------|------------------------------------------------------|
| Method Name                            | Description                                          |
|----------------------------------------|------------------------------------------------------|
| `isGet()`                              | Checks if this is a GET request.                     |
|----------------------------------------|------------------------------------------------------|
| `isPost()`                             | Checks if this is a POST request.                    |
|----------------------------------------|------------------------------------------------------|
| `isXmlHttpRequest()`                   | Checks if this request is an AJAX request.           |
|----------------------------------------|------------------------------------------------------|
| `isFlashRequest()`                     | Check if this request is a Flash request.            |
|----------------------------------------|------------------------------------------------------|
| `getMethod()`                          | Returns the method for this request.                 |
|----------------------------------------|------------------------------------------------------|
| `getUriString()`                       | Returns the URI for this request object as a string. |
|----------------------------------------|------------------------------------------------------|
| `getQuery($name, $default)`            | Returns the query parameter by name, or all query parameters. 
|                                        | If a parameter is not found, returns the `$default` value.|    
|----------------------------------------|------------------------------------------------------|
| `getPost($name, $default)`             | Returns the parameter container responsible for post |
|                                        | parameters or a single post parameter.               |
|----------------------------------------|------------------------------------------------------|
| `getCookie()`                            | Returns the Cookie header.                            |
|----------------------------------------|------------------------------------------------------|
| `getFiles($name, $default)`            | Returns the parameter container responsible for file |
|                                        | parameters or a single file.                         |
|----------------------------------------|------------------------------------------------------|
| `getHeaders($name, $default)`          | Returns the header container responsible for headers |
|                                        | or all headers of a certain name/type.               |
|----------------------------------------|------------------------------------------------------|
| `getHeader($name, $default)`           | Returns a header by `$name`. If a header is not found,   |
|                                        | returns the `$default` value.                        |
|----------------------------------------|------------------------------------------------------|
| `renderRequestLine()`                  | Returns the formatted request line (first line) for  |
|                                        | this HTTP request.                                   |
|----------------------------------------|------------------------------------------------------|
| `fromString($string)`                  | A static method that produces a Request object from a|
|                                        | well-formed Http Request string                      |
|----------------------------------------|------------------------------------------------------|
| `toString()`                           | Returns the raw HTTP request as a string.            |
|----------------------------------------|------------------------------------------------------|

### Retrieving GET or POST Variables

To simply get a GET or POST variable from an HTTP request, you use the following code:

{line-numbers=on,lang=php}
~~~
// Get a variable from GET
$getVar = $this->params()->fromQuery('var_name', 'default_val');

// Get a variable from POST
$postVar = $this->params()->fromPost('var_name', 'default_val');
~~~

In the example above, we used the `Params` controller plugin, which provides you with
convenient methods of accessing GET and POST variables, uploaded files, etc.

In line 2 we use the `fromQuery()` method for retrieving a variable having name "var_name" from GET.
If such a variable does not present, the default value "default_val" is returned.
The default value is very convenient, because you don't have to use the `isset()` PHP
function to test if the variable exists.

In line 5 we use the `fromPost()` method to retrieve the variable from POST (line 5). The meaning
of this method's parameters is the same as for the `fromQuery()` method.

T> In ZF3, you must not access request parameters through traditional PHP `$_GET` and `$_POST`
T> global arrays. Instead, you use ZF3-provided API for retrieving the request data.

### Putting Data to HTTP Response

Although you typically do not interact with HTTP response data directly, you can do that
with the help of `getResponse()` method provided by `AbstractActionController` base class.
Table 4.4 contains the most important methods of the `Response` class:

{title="Table 4.4. Methods of `Zend\Http\PhpEnvironment\Response` class."}
|----------------------------------------|--------------------------------------------------------|
| Method Name                            | Description                                            |
|----------------------------------------|--------------------------------------------------------|
| `fromString($string)`                    | Populate response object from string.                 |
|----------------------------------------|------------------------------------------------------|
| `getCookie()`                            | Retrieves Cookie header.                              |
|----------------------------------------|------------------------------------------------------|
| `setStatusCode($code)`                   | Sets HTTP status code and (optionally) message.        |
|----------------------------------------|------------------------------------------------------|   
| `getStatusCode()`                        | Retrieves HTTP status code.                            |
|----------------------------------------|------------------------------------------------------|    
| `setReasonPhrase($reasonPhrase)`         | Sets the HTTP status message.                         |
|----------------------------------------|------------------------------------------------------|    
| `getReasonPhrase()`                      | Gets HTTP status message.                              |
|----------------------------------------|------------------------------------------------------|
| `getBody()`                              | Gets the body of the response.                         |
|----------------------------------------|------------------------------------------------------|
| `isForbidden()`                          | Checks if the response code is 404 Forbidden.         |
|----------------------------------------|------------------------------------------------------|
| `isNotFound()`                           | Checks if the status code indicates the resource is not found. |
|----------------------------------------|------------------------------------------------------|
| `isOk()`                                 | Checks whether the response is successful.          |
|----------------------------------------|------------------------------------------------------|
| `isServerError()`                        | Checks if the response is 5xx status code.           |
|----------------------------------------|------------------------------------------------------|     
| `isRedirect()`                           | Checks whether the response is 303 Redirect.         |
|----------------------------------------|------------------------------------------------------|    
| `isSuccess()`                            | Checks whether the response is 200 Successful.      |
|----------------------------------------|------------------------------------------------------|
| `renderStatusLine()`                     | Renders the status line header.                        |
|----------------------------------------|------------------------------------------------------|
| `toString()`                             | Renders entire response as HTTP response string.       |
|----------------------------------------|------------------------------------------------------|

## Variable Containers

After you retrieve the data from the HTTP request (or from other data sources, 
for example, from database), you would do something with that data (typically you will 
process the data with your model layer) and return the data from the action method. 

You can see that the `indexAction()` method of the Index controller returns an instance of the `ViewModel` class.
The `ViewModel` class is some kind of a *variable container*. All variables passed to 
its constructor, will be then automatically accessible by the view script.

Let's have some real-life example. We will create another action method in our `IndexController` class, which we 
will call the `aboutAction()`. The "about" action will display the *About* page of our site.
In the action method, we will create two variables containing information about our website,
and return the variables for rendering in a view with the help of `ViewModel` object:

{line-numbers=on,lang=php}
~~~
// The "about" action
public function aboutAction() {              
  
    $appName = 'HelloWorld';
    $appDescription = 'A sample application for the Using Zend Framework 3 book';
    
    // Return variables to view script with the help of
    // ViewObject variable container
    return new ViewModel([
        'appName' => $appName,
        'appDescription' => $appDescription
    ]);
  }
~~~ 

In lines 5-7, we create the `$appName` and `appDescription` variables. They store our application
name and description, respectively.

In lines 17-21, we pass the variables we've created to the constructor of the `ViewModel` object 
as an associative array. The array keys define the names of the variables which on return
will be accessible to view script.

The `ViewModel` class provides several methods that you can additionally use to 
set variables to `ViewModel` and and retrieve variables from it. The table 4.5 
provides the methods summary:

{title="Table 4.5. Methods of the ViewModel class"}
|--------------------------------|---------------------------------------------------------------|
| *Method name*                  | *Description*                                                 |
|--------------------------------|---------------------------------------------------------------|
| `getVariable($name, $default)` | Returns a variable by name (or default value if the variable  |
|                                | does not exist).                                              |
|--------------------------------|---------------------------------------------------------------|
| `setVariable($name, $value)`   | Sets a variable.                                              |
|--------------------------------|---------------------------------------------------------------|
| `setVariables($variables, $overwrite)`|  Sets a group of variables, optionally overwriting the |
|                                | existing ones.                                                |
|--------------------------------|---------------------------------------------------------------|
| `getVariables()`               | Returns all variables as an array.                            |
|--------------------------------|---------------------------------------------------------------|    
| `clearVariables()`             | Removes all variables.                                        |
|--------------------------------|---------------------------------------------------------------|

## Controller Registration

All controller classes belonging to a module should be registered in the *module.config.php* 
configuration file as follows:

{line-numbers=on,lang=php}
~~~
<?php
return [
  // ...
    
  'controllers' => [
    'factories' => [
      Controller\IndexController::class => InvokableFactory::class
      // Put other controllers registration here
    ],
  ],
    
  // ...
];
~~~

In line 5, we have the the *controllers* key, which contains the *factories* subkey. 
You should register your controllers here. To register a controller class, you
add the line in form of *key=>value* pair. The key should be the fully qualified name of the controller class,
like *Application\\Controller\\IndexController* (we can use the PHP `::class` keyword for class name resolution), 
and value should be the name of a factory class that would create the controller class for use. In our case,
we use the standard `InvokableFactory`, but you can create your own if you need.

I> By using the `InvokableFactory`, you tell Zend Framework
I> that it can invoke the controller by instantiating it with the `new` operator. This is the most
I> simple way of instantiating the controller. As an alternative, you can register your own factory
I> to create the controller instance, and inject dependencies into controller (we will see how to do that later). 

## When to Create a New Controller?

When your site grows in size, you should create new controller classes instead of putting
all actions to `IndexController`. The Index controller is used for defining the actions 
which work for your entire site. 
It is recommended to create new controller class for each model (or for most important ones) of your business logic domain. 

For example, you can create `UserController` to manage users of your site.
This controller would have the default "index" action for displaying the page
with all users, "add" action for adding a new user, "edit" action for editing
user's profile and "delete" action for deleting the user.

By analogy, you would create `PurchaseController` and its actions to manage the purchases of your products 
and implementing the shopping cart, `DownloadController` and its actions to manage file downloads for the site, 
etc.

## Controller Plugins

A *controller plugin* is a class which extends the functionality of *all controllers* in some way.

I> Without plugins, to extend the functionality of all controllers, you would have to 
I> create a custom base class, say `BaseController`, and
I> derive other controllers from that base class. This way can also be used, but from ZF3 creators' point of view, plugins are better
I> solution, because they use *class composition* [^foo], which provides better flexibility comparing
I> to class inheritance. You register your plugin controller and it automatically becomes 
I> accessible from all controllers of your app (`AbstactActionController` base class uses PHP's `__call()` 
I> magic method to proxy calls to registered controller plugins).

[^foo]: Composition is a relationship between two classes that is best described as a "has-a" and 
        "whole/part" relationship. The owner class contains a reference to another class (plugin). 
        The owner is responsible for the lifetime of the object it holds.

There are several standard controller plugins available out of the box (table 4.6), and we've already used one of 
them (the `Params` plugin) in one of our previous examples.

{title="Table 4.6. Standard Controller Plugins"}
|------------------------------------------|------------------------------------------------------|
| *Standard Plugin Class*                  | *Description*                                        |
|------------------------------------------|------------------------------------------------------|
| `Params`                                 | Allows to retrieve variables from HTTP request,      |
|                                          | including GET and POST variables.                    |
|------------------------------------------|------------------------------------------------------|
| `Url`                                    | Allows to generate absolute or relative URL addresses|
|                                          | from inside controllers.                             |
|------------------------------------------|------------------------------------------------------|
| `Layout`                                 | Gives access to layout view model for passing data to|
|                                          | layout template.                                     |
|------------------------------------------|------------------------------------------------------|
| `Identity`                               | Returns the identity of the user who has logged into the |
|                                          | web site.
|------------------------------------------|------------------------------------------------------|
| `FlashMessenger`                         | Allows to define "flash" messages which are stored in|
|                                          | session and can be displayed on a different web page.|
|------------------------------------------|------------------------------------------------------|
| `Redirect`                               | Allows to redirect the request to another controller's |
|                                          | action method.                                       |
|------------------------------------------|------------------------------------------------------|
| `PostRedirectGet`                        | Redirects the POST request, converting all POST variables |
|                                          | to GET ones.                                         |
|------------------------------------------|------------------------------------------------------|
| `FilePostRedirectGet`                    | Redirects the POST request, preserving uploaded files.|
|------------------------------------------|------------------------------------------------------|

Inside of the controller's action method, you access a plugin in the following way:

{line-numbers=on,lang=php}
~~~
// Access Url plguin
$urlPlguin = $this->url();

// Access Layout plugin
$layoutPlugin = $this->layout();

// Access Redirect plugin
$redirectPlugin = $this->redirect();
~~~

### Writing Own Controller Plugin

In your web sites, you will definitely need to create custom controller plugins.
For example, assume you need that all your controller classes to be able to check
whether a site user is allowed to access certain controller action. This can be 
implemented with the `AccessPlugin` class. 

The controller plugin should be derived from the `AbstractPlugin` class.
Plugins typically live in their own namespace `Plugin`, which is nested in 
`Controller` namespace:

{line-numbers=off,lang=php}
~~~
<?php
namespace Application\Controller\Plugin; 

use \Zend\Mvc\Controller\Plugin\AbstractPlugin;

// Plugin class
class AccessPlugin extends AbstractPlugin {

  // This method checks whether user is allowed
  // to visit the page 
  public function checkAccess($actionName){
    // ...
  }
}
~~~

To let Zend Framework 3 know about your plugin, you need to register 
it in your *module.config.php* file under the `controller_plugins` key.
See below for example:

{line-numbers=off,lang=php}
~~~
<?php
return [
  // ... 
 
  'controller_plugins' => [
    'factories' => [
      Controller\Plugin\AccessPlugin::class => InvokableFactory::class,
    ]
  ],
 
  // ...
];
~~~

After that, you'll be able to access your custom plugin from
all of your controller's actions in this way:

{line-numbers=off,lang=php}
~~~
// Check if site user is allowed to visit the "index" page
$isAllowed = $this->access()->checkAccess('index');
~~~

## Views

Views belong to the presentation layer of the web application, because their goal
is to produce HTML output returned by the web server to site visitors. 

In Zend Framework 3, you implement a view as a *template file*, which is a file 
having `.phtml` extension ("phtml" stands for PHP+HTML). View templates have such 
a name because they usually contain HTML code mixed with PHP code snippets used 
for rendering the web pages. 

Views typically live inside of the *view* subdirectory
of the module (see figure 4.5):

![Figure 4.5. View directory](images/mvc/views_dir.png)

Q> **Why are view template files not stored under module's source directory?**
Q>
Q> View templates (`.phtml` files) are not stored under module's `src/` directory,
Q> because they are not usual PHP classes and do not need to be resolved by a PHP
Q> class autoloading feature. View templates are resolved by the special ZF3 class
Q> called *view resolver*, and for this reason, view templates are stored under
Q> the module's `view` directory.

View templates can have different behaviors, based on variables you pass to them from the controller's
action method. Data are passed to view templates with the help of a `ViewModel` variable container.

For example, let's implement the view template for the `aboutAction()` of our Index controller.
The *About* page will display the title and some information about our Hello World application. 

To create the view template file, in your NetBeans window, navigate to *view/application/index* directory (see figure 4.6), 
and right click on the "index" directory name. From the context menu that appears,
select the *New->PHP File...* menu item. 

In the "New PHP File" dialog that appears (figure 4.7), enter the name *about.phtml* and click the *Finish* button.

The *about.phtml* view template file will be created and displayed in the right pane of NetBeans window.
In that file, enter the following: 

{line-numbers=on,lang=php}
~~~
<h1>About</h1>

<p>
    The Hello World application.
</p>

<p>
    Application name: <?= $appName; ?>
</p>

<p>
    Application description: <?= $appDescription; ?>.
</p>
~~~

![Figure 4.6. Context Menu](images/mvc/new_php_file.png)

As you can see, the view template is a usual HTML page with several PHP code fragments.
A view script just renders the data you pass to it with a `ViewModel` variable container.
For example, in line 9 we get the value of `$appName` variable and print it into the standard output stream. 

I> In your view script, you can also use simple flow control operations (like `if`, `foreach` or `switch`) to 
make the appearance of the page different depending on variable's value. 

Now let's look at how the page looks like in the web browser. Type "http://localhost/application/about"
URL in your browser's navigation bar. The About page should appear (see figure 4.8):

![Figure 4.7. Context Menu](images/mvc/new_php_file_dialog.png)

![Figure 4.8. About Page](images/mvc/about_page.png)

T> In general, the PHP code you use inside of views must be as simple as possible. 
T> Views typically do not modify the data you pass from controller. 
T> For example, a view can use the model you pass to it to walk through database table rows and render 
T> the items to an HTML page, but it should never create database tables or modify them itself.

## View Helpers

A *view helper* is typically a (relatively) simple PHP class whose goal is to render some part of a view.
You can invoke view helpers from any view template. With view helpers, you can create reusable widgets
(like menus, navigation bars, etc.) for your web pages.

I> View helpers are analogous to controller plugins: the controller plugins allow to "extend"
I> the functionality of controllers, and view helpers allow to "extend" the functionality of view
I> templates.

ZF3 provides many standard view helpers out of the box. In the table 4.7, some of them are
presented with a brief description:

{title="Table 4.7. Standard View Helpers"}
|------------------------------------------|------------------------------------------------------|
| *Standard Plugin Class*                  | *Description*                                        |
|------------------------------------------|------------------------------------------------------|
| `BasePath`                               | Allows to retrive the base path to the web application, |
|                                          | which is the absolute path to `APP_DIR`.             |
|------------------------------------------|------------------------------------------------------|
| `Url`                                    | Allows to generate absolute or relative URL addresses|
|                                          | from inside view templates.                          |
|------------------------------------------|------------------------------------------------------|
| `ServerUrl`                              | Retrieves the current request's URL.                 |
|------------------------------------------|------------------------------------------------------|
| `Doctype`                                | Helper for setting and retrieving the doctype HTML element |
|                                          | of the web page.                                     |
|------------------------------------------|------------------------------------------------------|
| `PageTitle`                              | Helper for setting the title HTML element            |
|                                          | of the web page.                                     |
|------------------------------------------|------------------------------------------------------|
| `HtmlList`                               | Helper for generating ordered and unordered HTML lists. |
|------------------------------------------|------------------------------------------------------|
| `ViewModel`                              | Helper for storing and retrieving the view model     |
|------------------------------------------|------------------------------------------------------|
| `Layout`                                 | Retrieves the layout template view.                  |
|------------------------------------------|------------------------------------------------------|
| `Partial`                                | Allows to render a "partial" view template.          |
|------------------------------------------|------------------------------------------------------|
| `InlineScript`                           | Helper for setting and retrieving script elements for|
|                                          | inclusion in HTML body section.                      |
|------------------------------------------|------------------------------------------------------|
| `Identity`                               | View helper to retrive the authenticated user's identity. |
|------------------------------------------|------------------------------------------------------|
| `FlashMessenger`                         | Allows to retrieve the "flash" messages stored in    |
|                                          | session.                                             |
|------------------------------------------|------------------------------------------------------|

To demonstrate the usage of a view helper, below we will show how to set a title for a web page.
Typically, it is required to give a different title per each web page. You can do this
with the `HeadTitle` view helper. For example, you can set the title for the *About*
page by adding the following PHP code in the beginning of the *about.phtml* view template:

{line-numbers=off,lang=php}
~~~
<?php
$this->headTitle('About');
?>
~~~

In the code above, we call the `HeadTitle` view helper and pass it the page title string ("About") 
as the argument. The `HeadTitle` view helper internally sets the text for the `<title>` HTML
element of your web page. Then, if you open the *About* page in your web browser, 
the page title will look like "About - Zend Skeleton Application" (see the figure 
below for an example):

![Figure 4.9. Setting page title for the About page](images/mvc/about_title.png)

I> We will discuss the view helpers in more details and provide 
I> more usage examples in the chapter [Page Appearance and Layout](#appearance).

## View Template Names & View Resolver

When you return data with the `ViewModel` variable container from your controller's 
action method, Zend Framework somehow knows the name of the corresponding view template 
file and its location. For example, for your `IndexController`'s `aboutAction()` method, 
ZF3 automatically uses the *about.phtml* view template. 

It may be a surprise, but the `ViewModel` partially contributes into view template resolving.
Actually the `ViewModel` class is more than just a variable container. Additionally, it 
allows to specify which view template should be used for page rendering. The summary
of methods provided for this purpose is shown in table 4.8.

{title="Table 4.8. Methods of the ViewModel class for setting and retrieving the view template name"}
|--------------------------------|---------------------------------------------------------------|
| *Method name*                  | *Description*                                                 |
|--------------------------------|---------------------------------------------------------------|
| `setTemplate()`                | Sets the view template name.                                  |
| `getTemplate()`                | Returns the view template name.                               |
|--------------------------------|---------------------------------------------------------------|

To set the view template name, you use the `setTemplate()` method. The `getTemplate()` method
returns the view template name currently set for the view model. 

The following code example shows how you can call the `setTemplate()` 
method from your `IndexController` class' `indexAction()` method to 
force ZF3 to use the *about.phtml* view template file for rendering the *Home* 
page, instead of the *index.phtml* file:

{line-numbers=on,lang=php}  
~~~
// Index action renders the Home page of your site.
public function indexAction() {
    
	// Use a different view template for rendering the page.
	$viewModel = new ViewModel();
	$viewModel->setTemplate('application/index/about');
	return $viewModel;
}
~~~

In the code above, we created a new instance of the `ViewModel` class as usual (line 5).

Then we called the `setTemplate()` method on the view model object (line 6) and
passed the name of the view template name as its argument. The view template name
is actually a relative path to the `about.phtml` file, minus file extension.

Finally, we returned the view model object from the action method (line 7).

However, calling the `setTemplate()` method in every action method is optional. 
If you don't do that, ZF2 will determine the view template name automatically 
by concatenating the current module name, controller name and action method name.

When Zend Framework has the template name, it only remains to determine the absolute path
to the corresponding *.phtml* file. This is also called the *view template resolving*.
View templates are resolved with the special Zend Framework's class called the *view resolver*.

In ZF3, there are two view resolvers out of the box: `TemplatePathStack` and `TemplateMapResolver`.
Both resolvers take a view template name as input, and return path to view template file as output.
The template name is composed of controller name followed by template name, like "application/index/about",
"application/index/index", "layout/layout" and so on. 

* The *template map resolver* uses a PHP nested array to determine path to view template file by its
  name. This way is fast, but you have to maintain some template map array and update it each
  time you add a new view script.
* The *template path stack resolver* assumes that the view template name can be mapped 
  to directory structure. For example, "index/about" template name maps to 
  *APP_DIR/module/Application/view/application/index/about.phtml*.
  This way is simpler, because you don't have to maintain any maps. 
  
View resolver settings are stored inside of your *module.php.config* file under the *view_manager* key:

{line-numbers=on,lang=php}
~~~
<?php
return [
  //...
    
  'view_manager' => [
    //...
        
    'template_map' => [
        'layout/layout'           => __DIR__ . '/../view/layout/layout.phtml',
        'application/index/index' => __DIR__ . '/../view/application/index/index.phtml',
        'error/404'               => __DIR__ . '/../view/error/404.phtml',
        'error/index'             => __DIR__ . '/../view/error/index.phtml',
    ],
    'template_path_stack' => [
      __DIR__ . '/../view',
    ],
  ),
);
~~~

You can see that template map resolver's settings are stored under the *template_map* key. By default,
there are several "standard" view templates, which are resolved this way: the index page template, the layout template
(we will talk about it in [Page Appearance and Layout](#appearance)) and error templates (we will talk about them
a little bit later). These standard pages are served with this type of resolver, because it is
fast.

The template path stack resolver's settings are stored under the *template_path_stack* key.
You can see that this resolver looks for your view scripts under the "view" directory of your module.
That's why we could just put *about.phtml* file under that directory, and ZF will automatically find the
template.

The template map resolver and template path stack resolver work in pair. First, the fast template map
resolver tries to find the template view in its array map, and if the page is not found,
the template path stack resolver is executed.

## Disabling the View Rendering

Sometimes, you would need to disable the default view rendering.
To do that, just return the `Response` object from the the controller's action.

For example, let's create a `DownloadController` class, and add the "file" action, 
which would allow site users to download files from your web site. This 
action does not need a corresponding *file.phtml* view template, because it dumps file contents 
to PHP standard output stream and exits.

Add the *DownloadController.php* file to *Controller* directory of *Application* module, then
put the following code into the file:

{line-numbers=on,lang=php}
~~~
<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;

/**
 * This is the controller class for managing file downloads.
 */
class DownloadController extends AbstractActionController {

  /**
   * This is the 'file' action that is invoked
   * when a user wants to download the given file.     
   */
  public function fileAction() 
  {
    // Get the file name from GET variable
    $fileName = $this->params()->fromQuery('name', '');
	
    // Take some precautions to make file name secure
    str_replace("/", "", $fileName);  // Remove slashes
    str_replace("\\", "", $fileName); // Remove back-slashes
	
    // Try to open file
    $path = './data/download/' . $fileName;
    if (!is_readable($path)) {
      // Set 404 Not Found status code
      $this->getResponse()->setStatusCode(404);            
      return;
    }
		
    // Get file size in bytes
    $fileSize = filesize($path);

    // Write HTTP headers
    $response = $this->getResponse();
    $headers = $response->getHeaders();
    $headers->addHeaderLine(
                 "Content-type: application/octet-stream");
    $headers->addHeaderLine(
                 "Content-Disposition: attachment; filename=\"" . 
			     $fileName . "\"");
    $headers->addHeaderLine("Content-length: $fileSize");
    $headers->addHeaderLine("Cache-control: private"); 
		
    // Write file content        
    $fileContent = file_get_contents($path);
    if($fileContent!=false) {                
      $response->setContent($fileContent);
    } else {        
      // Set 500 Server Error status code
      $this->getResponse()->setStatusCode(500);
      return;
    }
	
    // Return Response to avoid default view rendering
    return $this->getResponse();
  }
}
~~~

The action method takes the *name* parameter from URL's query part (line 19),
removes slashes from file name (lines 22-23), adds HTTP headers to `Response` object 
(lines 39-45) and file contents (lines 48-55). Finally, it returns the `Response` object
to disable the default view rendering.

Register the `DownloadController` class by adding the following line to
your *module.config.php* file:

{line-numbers=off,lang=php}
~~~
<?php
return [
  // ...    
  'controllers' => [
    'factories' => [
      // ...
      Controller\DownloadController::class => InvokableFactory::class
    ],
  ],    
  // ...
);
~~~

You will also need to add a *route* to your *module.config.php* (a route tells ZF3 to what URL to map the
controller action). Modify the `routes` key of the config file as follows:

{line-numbers=off,lang=php}
~~~
<?php
return [
  // ...    
  'router' => [
        'routes' => [
            // Add this route for the DownloadController
            'download' => [
                'type'    => Segment::class,
                'options' => [
                    'route'    => '/download[/:action]',
                    'defaults' => [
                        'controller'    => Controller\DownloadController::class,
                        'action'        => 'index',
                    ],
                ],
            ],
        ],
    ], 
  // ...
);
~~~

To see how the file download works, create *APP_DIR/data/download* directory
and put some text file named *sample.txt* in it. Then open your web browser and type the URL 
"http://localhost/download/file?name=sample.txt" in 
your browser's navigation bar and press the Enter key. The browser will download 
the *sample.txt* file and offer you to save it to some location.

## Error Pages

When a page could not be found or some other error happens inside of your web application,
a standard error page is displayed. The appearance of the error page is controlled by the
error templates. There are two error templates: *error/404* which is used for "404 Page Not Found"
error (shown in figure 4.10), and *error/index* which is displayed when a generic error occurs (such as an unhandled exception is thrown somewhere
inside of the application). 

![Figure 4.10. 404 Error Page](images/mvc/error_404.png)

The *module.config.php* file contains several parameters under the *view_manager* key, which you can use 
to configure the appearance of your error templates:

{line-numbers=on,lang=php}
~~~
<?php
return [
  //...
    
  'view_manager' => [    
    'display_not_found_reason' => true,
    'display_exceptions'       => true,
    //...
    'not_found_template'       => 'error/404',
    'exception_template'       => 'error/index',    
    'template_map' => [
      //...
      'error/404' => __DIR__ . '/../view/error/404.phtml',
      'error/index'=> __DIR__ . '/../view/error/index.phtml',
    ],
    //...
  ],
];
~~~

* The *display_not_found_reason* parameter controls whether to display the detailed
  information about the "Page not Found" error.
* The *display_exceptions* parameter defines whether to display information about
  an unhandled exception and its stack trace.
* The *not_found_template* defines the template name for the 404 error.
* The *exception_template* specifies the template name for the unhandled exception error.

T> You typically set the *display_not_found_reason* and *display_exceptions* parameters
T> to `false` in production systems, because you don't want site visitors see the details
T> about errors in your site. However, you will still be able to retrieve the detailed
T> information from Apache's `error.log` file.
   
## Models

A *model* is a PHP class which contains the business logic of your application. 
The business logic is the "core" of your web site. It implements the goal of site
operation. For example, if you implement an E-shop web site, you will have models
implementing the product catalog and the shopping cart.

In general, the term model means a simplified representation of a real-life object
or phenomenon. Simplified because the real-life object has infinite amount 
of properties. For example, a real-life person who visits your site consists of billions of atoms, 
and you cannot describe them all. Instead, you take several properties of the object, 
which are the most important for your system and ignore all others.
For example, the most important properties of the site visitor (from web site architect's point of view) are 
first name, last name, country, city, ZIP code and street address. 

Models can have some behavior. For example, a mailer model 
may send E-mail messages, the currency converter model may 
be able to convert money and so on. 

With ZF3, you represent models as usual PHP classes. 
Properties are implemented as class fields, and
the behaviors are implemented as class methods. 

## Model Types

In Zend Framework 3, there is no single `Model` directory for storing the model classes, as you could
assume. Instead, by convention, models are further subdivided into the following types, and each type is
stored in its own subdirectory (see table 4.9):

{title="Table 4.9. Model Types and their Location"}
|--------------------------------|----------------------------------------------------------|
| *Model Type*                   | *Directory*                                              |
|--------------------------------|----------------------------------------------------------|
| Entities                       | `APP_DIR/module/Application/src/Entity`                  |
|--------------------------------|----------------------------------------------------------|
| Value Objects                  | `APP_DIR/module/Application/src/ValueObject`             |
|--------------------------------|----------------------------------------------------------|
| Services                       | `APP_DIR/module/Application/src/Service`                 |
|--------------------------------|----------------------------------------------------------|
| Repositories                   | `APP_DIR/module/Application/src/Repository`              |
|--------------------------------|----------------------------------------------------------|
| Factories                      | In `Factory` subdirectory under each model type directory.|
|                                | For example, controller factories would be stored in `APP_DIR/module/Application/src/Controller/Factory`     |
|--------------------------------|----------------------------------------------------------|

I> Separation of models into different types make it easier to design your business logic domain.
I> This is also called the "Domain Driven Design" (or shortly, DDD). The person who proposed DDD was Eric Evans
I> in his famous book called *Domain-Driven Design — Tackling Complexity in the Heart of Software*.

### Entities

*Entities* always have some *identifier* property, so you can uniquely identify the object. 
For example, a `User` entity always has a unique `login` property,
and you can identify the user by that attribute. You can change some other attributes
of the entity, like `firstName`, or `address`, but its identifier never changes.
Entity models are usually stored in a database, in a file system or in any other storage.

Below, you can find an example a `User` entity, which represents a site visitor:

{line-numbers=on, lang=php}
~~~
// The User entity represents a site visitor
class User {

  // Properties
  private $login;     // e.g. "admin"
  private $title;     // e.g. "Mr."
  private $firstName; // e.g. "John"
  private $lastName;  // e.g. "Doe"
  private $country;   // e.g. "USA"
  private $city;      // e.g. "Paris"
  private $zipCode;   // e.g. "10543"
  private $address;   // e.g. "Jackson rd."
    
  // Behaviors    
  public getLogin() {
    return $this->login;
  }
        
  public setLogin($login) {
    $this->login = $login;
  }
    
  //...
}
~~~

In lines 5-10, we define `User` model's properties. The best practice is to 
define the properties using the private access type, and make
them available to the caller through *getter* and *setter* public methods 
(like `getLogin()` and `setLogin()`, etc). 

I> Model's behavior methods are not limited by getters and setters.
I> You can create other methods which manipulate with model's data.
I> For example, you can define the `getFullName()` convenience method,
I> which would return the user's full name, like "Mr. John Doe".

### Value Objects

*Value objects* are a kind of model for which the identity is not as important as for entities.
A value object is usually a small class identified by all of its attributes. 
It does not have an identifier attribute. Value objects typically have getter methods, but do not 
have setters (value objects are immutable). 

For example, a model wrapping a money amount can be 
treated as a value object:

{line-numbers=on, lang=php}
~~~
class MoneyAmount {
  
  // Properties
  private $currency;
  private $amount;
  
  // Constructor
  public function __construct($amount, $currency='USD') {
    $this->amount = $amount;
    $this->currency = $currency;
  }
  
  // Gets the currency code  
  public function getCurrency() {
    return $this->currency;  
  }
  
  // Gets the money amount
  public function getAmount() {
    return $this->amount;
  }  
}
~~~

In lines 4-5 we define two properties: `currency` and `amount`. The model
has no identifier property, instead it is identified by all properties as
a whole: if you change either the `currency` or `amount`, you would have a 
different money amount object.

In lines 8-10 we define the constructor method, which initializes the properties.
In lines 14-21, we define getter methods for model's properties. Note that we
do not have setter methods (the model is immutable).

### Services

*Service models* usually encapsulate some business logic functionality. 
Services usually have easily recognizable names ending with "er" suffix, like `FileUploader` or `UserManager`. 

Below, an example of `Mailer` service is presented. It has the `sendMail()`
method which takes an `EmailMessage` value object and sends an E-mail message
using standard PHP `mail()` function:

{line-numbers=off,lang=php}
~~~
<?php

// The Email message value object
class EmailMessage {  
  private $recipient;
  private $subject;
  private $text;  
  
  // Constructor
  public function __construct($recipient, $subject, $text) {
    $this->recipient = $recipient;
    $this->subject = $subject;
    $this->text = $text;
  }
  
  // Getters
  public function getRecipient() {
    return $this->recipient;
  }
  
  public function getSubject() {
    return $this->subject;
  }
  
  public function getText() {
    return $this->text;
  }
}

// The Mailer service, which can send messages by E-mail
class Mailer {
  
  public function sendMail($message) {
    // Use PHP mail() function to send an E-mail
    if(!mail($message->getRecipient(), $message->getSubject(), 
             $message()->getText())) 
    {
      // Error sending message
      return false
    }
    
    return true;
  }
}
~~~

### Factories

*Factories* are usually being designed to instantiate other models. In the simplest cases you 
can create an instance of a class without any factory, just by using the `new` operator, but 
sometimes class creation logic might be very complex, and you encapsulate it inside of a factory class. 
Factory classes typically have names ending with `Factory` suffix, like 
`IndexControllerFactory`, `MailerFactory`, etc.

For example, let's consider the case when you use a CAPTCHA image in a web form. The image
is a type of challenge-response test used to determine whether the user is a human or a robot.
There may be different CAPTCHA types: simple image captcha, [reCAPTCHA](http://www.google.com/recaptcha) and so on.
Let's create a fictitious `CaptchaFactory` class, whose only goal is to
create different CAPTCHA images based on the `type` argument you pass to its `createCaptcha()`
method. 

{line-numbers=off,lang=php}
~~~
use Zend\ServiceManager\Factory\FactoryInterface;

// The CaptchaFactory class is used to create CAPTCHA
// image for a web form.
class CaptchaFactory extends FactoryInterface
{
  // Creates a CAPTCHA object based on type parameter
  public function __invoke(ContainerInterface $container, $requestedName, array $options) 
  {
    $type = $options['type'];
    if($type=='Image')
      return new ImageCaptcha();
    else if($type=='ReCaptcha')
      return new ReCaptcha();
    else
      throw new Exception('Unknown captcha type');
  }
}
~~~

### Repositories

*Repositories* are specific models responsible for storing and retrieving entities.
For example, a `UserRepository` may represent a database table and provide methods
for retrieving `User` entities. You typically use repositories when storing entities
in a database. With repositories, you can encapsulate SQL query logic in the
single place and easily maintain and test it.

I> We will learn about repositories in more details in [Database Management with Doctrine](#doctrine), when
I> talking about Doctrine library.

## Determining the Correct Model Type

Q> **Isn't it confusing to have so many model types?**
Q>
Q> Well, yes and no. At first, it may be a little difficult to determine
Q> the correct model type, but as soon you improve your
Q> skills, you will be able to do that intuitively. Just remember that model types improve the
Q> structure of your domain models. 

When writing your own application having specific model domain, you may be confused
when trying to decide to which model type your class belongs (whether it is an entity,
value object, repository, service or factory). Below, a simple algorithm
is provided to make it easier for you to determine the correct model type
when writing your own application:

* Your model class is definitely a *Service*
    * if it encapsulates some business logic
    * if you call it from your controller class
    * if you think the best name for it ends with "er": suffix, like `FileUploader` or `VersionChecker`
* Your model class is an *Entity*:
    * if your model is stored in a database
    * if it has an ID attribute
    * if it has both getters and setters methods
* Your model class is a *ValueObject*:
    * if changing any attribute would make the model completely different
    * if your model has getters, but not setters (immutable)
* Your model is a *Repository*:
    * if it works with a database to retrieve entities    
* Your model is a *Factory*:
    * if it can create other objects and can do nothing else

Q> **Hmm... what if I just store all my models in a single Model directory?**
Q>
Q> Of course, you can, if you strongly wish. But, when you use Doctrine ORM
Q> library, you will notice that it utilizes DDD principles as well, so using DDD
Q> makes your application well-organized.

## Skinny Controllers, Fat Models, Simple Views

When developing a web site using Model-View-Controller pattern, there is a risk
of misunderstanding the role of controllers, views and models. This results in making the
controllers huge and models small, which in turn makes it difficult to test and support 
your application. This section's goal is to give you a general understanding of what 
code may be placed in a controller class, what code may be placed in a view template, 
and what code may be placed in a model class.

### Skinny Controllers

The idea behind the term "skinny controller" is that typically, in your controller classes, 
you put only the code that:

* accesses user request data (`$_GET`, `$_POST`, `$_FILES` and other PHP variables);
* checks the validity of the input data;
* (optionally) makes some basic preparations to the data;
* passes the data to model(s) and retrieves the result returned by the model(s);
* and finally returns the output data as a part of a `ViewModel` variable container.

A controller class should avoid:

* containing complex business logic, which is better kept in model classes;
* containing any HTML or any other presentational markup code. This is better 
  be put in view templates.

For an example of a "skinny" controller, look at the `CurrencyConverterController` 
class below. This controller provides the "convert" action method whose goal is to convert 
an amount of money from EUR to USD currency. The user passes the amount of money through the
"amount" GET variable.

{line-numbers=on,lang=php}  
~~~
class CurrencyConverterController extends AbstractActionController {
  
  // Currency converter model
  private $currencyConverter;

  // Constructor. It's purpose is to "inject" dependencies.
  public function __construct($currencyConverter)
  {
    $this->currencyConverter = $currencyConverter;
  }

  // The "convert" action displays the converted money amount
  public function convertAction() {
  
    // Get the money amount from GET
    $amount = (float)$this->params()->fromQuery('amount', -1);
    
    // Validate input data
    if($amount<0) {
      // Money amount is missing
      $this->getResponse()->setStatusCode(404);
      return;
    }
 
    // Pass the data to the CurrencyConverter model
    $convertedAmount = $this->currencyConverter->convertEURtoUSD($amount);	
		
    return new ViewModel([
      'amount'=>$amount,
      'convertedAmount'=>$convertedAmount
    ]);
  }
}
~~~

The controller's action method above does the following:

* Takes the data passed by site user (line 6). This data is usually part of 
 `Request` object and can be retrieved using the controller's `getRequest()` method 
  or `Params` controller plugin.

* Performs the basic check on the data passed by user (line 7), and if the data is missing (or invalid),
  sets an HTTP error code (line 9). 
    
* Creates the `CurrencyConverter` model (line 14) and passes the money amount
  to the model by calling its `convertEURtoUSD()` method. The method
  then returns the converted amount.

* Constructs the `ViewModel` variable container and passes the resuting
  data to it (line 17). This variable container can be further accessed in the corresponding 
  view template responsible for data presentation.
  
### Fat Models

Because you need to keep your controllers as thin as possible, 
most of the business logic of your application should be put into 
model classes. In a  properly designed Model-View-Controller application, 
models look "huge". A model class may contain the code which:

* Performs complex data filtering and validation. Because the data that you retrieved
  in controller is passed to
  your application from an outside world, in your model, you have to take a lot of effort 
  to verify the data and ensure the data will not break your system. This
  results in a secure web site resistent to hacker attacks. 
  
* Performs data manipulation. Your models should manipulate the data: e.g. load the data from database, 
  save it to database and transform the data. Models are the right place for storing database queries,
  file reading and writing functionality, and so on.

In a model class you are not recommended to:

* Access the data from the HTTP request, `$_GET`, `$_POST` and other PHP variables. It is the controller's
  work to extract that data and pass it to model's input.

* Produce HTML or other code specific to presentation. The presentational code may vary 
  depending on the user request, and it is better to put it in a view template.
  
If you follow these principles, you will encounter that your models are easy to
test, because they have clearly identified input and output. You can write a unit test which 
passes some test data to input end of the model, retrieves the output data and verifies that the
data is correct. 

If you are confused whether to put certain code in a controller or in a model,
ask yourself: is this an important business logic that needs to be carefully tested? If the answer
is yes, you should put the code in a model.
  
### Simple View Templates

Because most of the logic is stored in models, your view templates should be as
simple as possible to produce the presentation of the data passed through the 
variable container. In a view template, you may:

* Keep static HTML markup code.

* Retrieve the data from a variable container and echo them to PHP output stream.

* If a controller passed a certain model through a variable container, poll the model
  for data (e.g. you can retrieve table rows from a database table and render them).
  
* Contain simple PHP flow control operations, like `if`, `foreach`, `switch` and so on. This
  allows to vary the presentation depending on variables passed by the controller.
  
The view template is not recommended to:

* Access data from the HTTP request and PHP variables.

* Create models, manipulate them and modify the state of the application.

If you follow these principles, you will encounter that your views can easily be
substituted without modifying the business logic of your application. For example,
you can easily change the design of your web pages, or even introduce changable themes.

## Summary

A Zend Framework 3 based web site is just a PHP program receiving an HTTP request from 
the web server, and producing an HTTP response. 
The web application uses the Model-View-Controller pattern to separate business logic
from presentation. The goal of this is to allow for code reusability and separation of concerns.

A controller is a mediator between the application, models and views: 
it gets input from HTTP request and uses the model(s) and the corresponding view 
to produce the necessary HTTP response. A controller is a usual PHP class
containing action methods.

Views are simple HTML+PHP code snippets producing HTML output returned by the web 
server to site visitors. You pass the data to view scripts through the `ViewModel` 
variable container.

A model is a PHP class which contains the business logic of your application. 
The business logic is the "core" of your web site which implement the goal of site
operation. Models can access database, manipulate disk files, connect to external
systems, manipulate other models and so on.
